<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杨根威的博客</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 19 Apr 2018 10:24:32 +0800</pubDate>
    <lastBuildDate>Thu, 19 Apr 2018 10:24:32 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>Swift - 类和结构体</title>
        <description>&lt;p&gt;在面向过程的语言中,要想实现类似类的功能只能借助结构体,其实从OC源码也能看出来,类的组成本就是复杂的结构体实现的。
而在Swift中结构体的功能被扩大化了，基本拥有了和类差不多的功能:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;定义属性&lt;/li&gt;
    &lt;li&gt;定义方法&lt;/li&gt;
    &lt;li&gt;定义getter和setter&lt;/li&gt;
    &lt;li&gt;可以定义初始化器来设置初始状态&lt;/li&gt;
    &lt;li&gt;实现扩展的功能&lt;/li&gt;
    &lt;li&gt;遵循协议,并实现协议的方法&lt;/li&gt;
    &lt;li&gt;结构总是被复制，并且不使用引用计数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;类具有结构不具备的附加功能:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;继承允许一个类继承另一个类的特征。&lt;/li&gt;
    &lt;li&gt;类型转换使您能够在运行时检查和解释类实例的类型。&lt;/li&gt;
    &lt;li&gt;初始化器使一个类的实例能够释放它所分配的任何资源。&lt;/li&gt;
    &lt;li&gt;引用计数允许多个引用到一个类实例。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;定义结构体和类&quot;&gt;定义结构体和类&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class className {

}

struct structName {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们为类和结构体添加一些变量和方法:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Resolution {
    var width = 0
    var height = 0
    
    func resolutionFun() {
        print(&quot;method of struct Resolution&quot;)
    }
}

class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
    
    func VideoMode() {
        print(&quot;method of class VideoMode&quot;)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;类和结构体的初始化&quot;&gt;类和结构体的初始化&lt;/h1&gt;
&lt;p&gt;定义是一回事,初始化又是另一回事。我们来看如何初始化它们:
let &lt;code class=&quot;highlighter-rouge&quot;&gt;object Name&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;Class Name&lt;/code&gt;()
let  &lt;code class=&quot;highlighter-rouge&quot;&gt;variable Name&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;Struct Name&lt;/code&gt;()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someResolution = Resolution()
let someVideoMode = VideoMode()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;访问属性&quot;&gt;访问属性&lt;/h1&gt;
&lt;p&gt;Swift中访问属性使用的是链式结构,访问属性的时候使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;object name&lt;/code&gt;.&lt;code class=&quot;highlighter-rouge&quot;&gt;propertyName&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(&quot;The width of someResolution is \(someResolution.width)&quot;)
print(&quot;The width of someVideoMode is \(someVideoMode.resolution.width)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;类或者结构中的属性默认情况是可写可读的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;someVideoMode.resolution.width = 1280
print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关于直接修改类中结构的数据,这一点与OC是不同的，OC中并没有处理好这一层级关系,导致类的中结构体是只读的，无法去修改。而Swift允许您直接设置结构属性的子属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;结构体的初始化&quot;&gt;结构体的初始化&lt;/h1&gt;
&lt;p&gt;所有结构都有一个自动生成的成员智能初始化器，您可以使用它来初始化新结构实例的成员属性:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Resolution {
    var width = 0
    var height = 0
}

let resolution = Resolution(width:100,height:120)
print(&quot;width:\(resolution.width),height:\(resolution.height)&quot;)
结果:
width:100,height:120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而类并不具备这样的初始化器,如果需要特定的初始化需要去自定义,那么如何创建类似这样的初始化器呢?
首先要知道初始化器是系统本身的方法,我们只能去重写或者重载它&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class VideoMode {
    var _name: String
    
    init(){
        _name = &quot;Jin&quot;
    }
}

let videoModeNormal = VideoMode()
print(&quot;name:\(videoModeNormal._name)&quot;)
结果:
name:Jin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们重写了系统默认的init()初始化方法,并且设定我们想定义的功能。&lt;/p&gt;

&lt;p&gt;那么我们如何去实现像结构体那样的初始功能呢?
这时候我们需要用到重载功能.
&lt;strong&gt;重载就是将父类已有的方法通过扩充参数的形式重新定义一遍。&lt;/strong&gt;
我们可以看一下对比:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class VideoMode {
    var _name: String
    
    init(){
        _name = &quot;Jin&quot;
    }
    
    init(name:String){
        _name = name;
    }
    
}

let videoModeNormal = VideoMode()
print(&quot;name:\(videoModeNormal._name)&quot;)
let videoModeCustom = VideoMode(name: &quot;Jack&quot;)
print(&quot;name:\(videoModeCustom._name)&quot;)
结果:
name:Jin
name:Jack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们类中申明了两个初始化方法,通过我们在实例化的时候使用不同的初始化方式,系统会自动识别使用哪个方法。
例如调用&lt;code class=&quot;highlighter-rouge&quot;&gt;VideoMode()&lt;/code&gt;的时候系统会调用init()方法,调用&lt;code class=&quot;highlighter-rouge&quot;&gt;VideoMode(name: &quot;Jack&quot;)&lt;/code&gt;的时候，系统会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;init(name:String)&lt;/code&gt;方法。
当然,struct的初始化方法也是可以这样实现的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Resolution {
    var width: Double
    
    init(){
        width = 100
    }
    
    init(width:Double){
        self.width = width;
    }
    
}

let resolutionNormal = Resolution()
print(&quot;width:\(resolutionNormal.width)&quot;)
let resolutionCustom = Resolution(width: 120)
print(&quot;width:\(resolutionCustom.width)&quot;)
结果:
width:100.0
width:120.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用init初始化方法,必须初始化结构体或者类中所有的属性。当然,如果该属性定义的时候已经初始化可以不用。
初始化可以参数下面的设定&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var width: Double = 0
    var height: Double = 0
    
    init(){
        width = 100
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你像下面这样写,会报出:Return from initializer without initializing all stored properties(提示你返回的时候,并没有将所有属性初始化)的错误&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var width: Double = 0
    var height: Double 
    
    init(){
        width = 100
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;类的初始化&quot;&gt;类的初始化&lt;/h1&gt;
&lt;p&gt;上面大致了解了结构体的初始化,还有一些类的初始化.虽然两者很多地方是相同.但总有一些不同的地方.
class 的设定中,初始化分为了指定初始化(Designated initializers)和便利初始化(Convenience initializers).
指定初始化就是我们上面讲的:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;init(&lt;code class=&quot;highlighter-rouge&quot;&gt;parameters&lt;/code&gt;) {
    &lt;code class=&quot;highlighter-rouge&quot;&gt;statements&lt;/code&gt;
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而便利初始化是无法独立运作的。它设定是这样的:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;convenience init(&lt;code class=&quot;highlighter-rouge&quot;&gt;parameters&lt;/code&gt;) {
    &lt;code class=&quot;highlighter-rouge&quot;&gt;statements&lt;/code&gt;
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以是实验一下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Resolution {
    var width: Double = 0
    var height: Double = 0
    
    init(){
        width = 100
    }
    
   convenience init(height:Double){
        self.height = height;
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;会报错:
Use of ‘self’ in property access ‘height’ before self.init initializes self
Self.init isn’t called on all paths before returning from initializer
这两个错误简单来说反应的就是这个init目前来说并不具备系统的init功能,它其实只是我们自定义的方法,但因为使用了init关键字,系统就无法理解这种行为了。 而要想让它发生作用,我们需要它本身加入init方法的功能。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   convenience init(height:Double){
        self.init()
        self.height = height;
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以了。
而Swift本生也指定了这样的规则:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Rule 1
A designated initializer must call a designated initializer from its immediate superclass.
指定的初始化器必须从其直接的超类调用指定的初始化器。&lt;/li&gt;
    &lt;li&gt;Rule 2
A convenience initializer must call another initializer from the same class.
一个convenience修饰的初始化器必须从同一个类调用另一个初始化器。&lt;/li&gt;
    &lt;li&gt;Rule 3
A convenience initializer must ultimately call a designated initializer.
一个convenience修饰的初始化器必须最终调用一个指定的初始化器。
这些规则如下图所示:&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-1aff71fcf52922b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640&quot; alt=&quot;initializerDelegation.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，超类有一个指定的初始化器和两个方便的初始化器。一个方便初始化器调用另一个方便初始化器，它依次调用单个指定的初始化器。这满足了上面的规则2和3。超类本身没有进一步的超类，因此规则1不适用。&lt;/p&gt;

&lt;p&gt;这个图中的子类有两个指定的初始化器和一个方便的初始化器。方便初始化器必须调用两个指定的初始化器中的一个，因为它只能从同一个类调用另一个初始化器。这满足了上面的规则2和3。两个指定的初始化器都必须从超类调用单个指定的初始化器，以满足上面的规则1。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些规则不会影响您的类的用户如何创建每个类的实例。上图中的任何初始化器都可以用来创建它们所属的类的完全初始化实例。这些规则只会影响您如何编写类的初始化器的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图显示了四个类的更复杂的类层次结构。它演示了这个层次结构中指定的初始化器如何充当类初始化的“漏斗”点，简化了链中的类之间的相互关系:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-15ca4ea02f16d07f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540&quot; alt=&quot;initializerDelegation02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看似复杂的关系,其实也很简单。
父类的init方法是会被继承的,而它的子类如果选择继承父类的初始化方法,而想创建convenience修饰的初始化器，就必然需要使用各自类中的init方法。&lt;/p&gt;

&lt;h1 id=&quot;两阶段初始化&quot;&gt;两阶段初始化&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.
Swift中的类初始化是一个两阶段过程。在第一阶段中，每个存储的属性都由引入它的类分配一个初始值。一旦确定了每个存储属性的初始状态，第二个阶段就开始了，并且每个类都有机会在新实例准备好使用之前进一步定制它的存储属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.
使用两阶段的初始化过程使初始化更加安全，同时仍然为类层次结构中的每个类提供完全的灵活性。两阶段初始化防止在初始化前访问属性值，并防止属性值被另一个初始化器设置为不同的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift’s two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as 0 or nil) to every property. Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which 0 or nil is not a valid default value.
Swift的两阶段初始化过程类似于在Objective-C中初始化。主要的区别在于，在第1阶段，Objective-C中对每个属性都赋值0或null值(例如0或nil)。Swift的初始化流更灵活，它允许您设置自定义的初始值，并且可以处理0或nil不是有效的默认值的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Swift的编译器执行四个有用的安全检查，以确保两阶段的初始化是没有错误的完成的:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Safety check 1
A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.
一个指定的初始化器必须确保它的类所引入的所有属性在它委托给一个超类初始化器之前被初始化。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.
正如上面所提到的，只有当所有存储属性的初始状态被知道时，对象的内存才会被完全初始化。为了让这个规则得到满足，一个指定的初始化器必须确保所有的属性都在它被连接到链之前被初始化。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Safety check 2
A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.
指定的初始化器必须在将一个值赋值给继承属性之前将其委托给一个超类初始化器。如果没有，指定初始化器分配的新值将被超类作为其自身初始化的一部分重写。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Safety check 3
A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.
一个便利的初始化器必须委托给另一个初始化器，然后将一个值赋给任何属性(包括由同一个类定义的属性)。如果它不这样做，那么方便初始化器分配的新值将被它自己的类的指定初始化器重写。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Safety check 4
An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.
一个初始化器不能调用任何实例方法，读取任何实例属性的值，或者将self作为一个值，直到初始化的第一阶段完成。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The class instance is not fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.
类实例在第一个阶段结束之前是不完全有效的。只有当类实例在第一阶段的末尾是有效的时，才可以访问属性，并且只能调用方法。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是第一阶段如何查找一个假设的子类和超类的初始化调用:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-103ca2b2df88cc20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640&quot; alt=&quot;第一阶段安全检查.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是两阶段的初始化是如何进行的，基于上面的四个安全检查:
阶段 1&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;A designated or convenience initializer is called on a class.
在类上调用指定的或方便的初始化器。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Memory for a new instance of that class is allocated. The memory is not yet initialized.
为该类的一个新实例的内存分配。内存还没有初始化。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;A designated initializer for that class confirms that all stored properties introduced by that class have a value. Thememory for these stored properties is now initialized.
这个类的指定初始化器确认了该类所引入的所有存储属性都有一个值。这些存储属性的内存现在已经被初始化了。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.
指定的初始化器交给一个超类初始化器，为它自己的存储属性执行相同的任务。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;This continues up the class inheritance chain until the top of the chain is reached.
这将继续继承类继承链，直到到达链的顶端。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.
一旦到达链的顶端，并且链中的最后一个类确保其所有的存储属性都有一个值，实例的内存就被认为是完全初始化的，而阶段1是完整的。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;这里的链就是&lt;code class=&quot;highlighter-rouge&quot;&gt;class.classProperty&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;连接起来的结构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;阶段2&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties, call its instance methods, and so on.
从链的顶部向下工作，链中的每个指定初始化器都可以选择进一步自定义实例。初始化器现在能够访问self并可以修改它的属性，调用它的实例方法，等等。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Finally, any convenience initializers in the chain have the option to customize the instance and to work with self.
最后，链中的任何方便的初始化器都可以选择自定义实例并与self一起工作。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是第2阶段如何查找相同的初始化调用:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-af426fd67630ee38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640&quot; alt=&quot;第二阶段安全检查.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官网给出的解释很是详尽的解释了初始化的工作步骤,虽然枯燥,但确实必须的。从这层工作中也看到了Swift相比于OC的安全和稳定性更加出色,比起OC更多时候因为意外导致的崩溃情况,Swift在这方面的检查机制要更加全面一点。&lt;/p&gt;

&lt;h1 id=&quot;初始化器继承和重写&quot;&gt;初始化器继承和重写&lt;/h1&gt;
&lt;p&gt;与Objective-C中的子类不同，Swift子类在默认情况下不会继承父类初始化器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.
Swift的方法防止了一种情况，即一个超类的简单初始化器是由一个更专门化的子类继承而来的，它被用来创建一个未完全或正确初始化的子类的新实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当您编写一个与超类指定初始化器相匹配的子类初始化器时，您实际上对指定的初始化器进行重写。因此，您必须在子类的初始化器定义之前编写&lt;code class=&quot;highlighter-rouge&quot;&gt;override&lt;/code&gt;修饰符。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Vehicle {
    var numberOfWheels = 0
}

class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;自动初始化继承&quot;&gt;自动初始化继承&lt;/h1&gt;
&lt;p&gt;As mentioned above, subclasses do not inherit their superclass initializers by default. However, superclass initializers are automatically inherited if certain conditions are met. In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.
正如上面提到的，子类在默认情况下不会继承父类初始化器。但是，如果满足某些条件，超类初始化器就会自动继承。在实践中，这意味着您不需要在许多常见的场景中重写初始化器，并且可以在安全的情况下以最小的工作量来继承您的超类初始化器。&lt;/p&gt;

&lt;p&gt;假设您为您在子类中引入的任何新属性提供了默认值，下面的两个规则适用:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;规则1
如果你的子类没有定义任何指定的初始化器，它会自动继承所有父类指定的初始化器。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;规则2
如果您的子类提供了所有超类指定的初始化器的实现，或者通过它们实现继承并遵守规则1，或者通过提供自定义实现作为其定义的一部分，那么它就会自动继承所有超类的方便初始化器。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;You can use both classes and structures to define custom data types to use as the building blocks of your program’s code.
您可以使用类和结构来定义定制的数据类型，以作为程序代码的构建块。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;However, structure instances are always passed by value, and class instances are always passed by reference. This means that they are suited to different kinds of tasks. As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.
但是，结构实例总是通过值传递，而类实例总是通过引用传递。这意味着它们适用于不同类型的任务。当您考虑一个项目需要的数据结构和功能时，决定每个数据结构是否应该被定义为一个类或一个结构。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;As a general guideline, consider creating a structure when one or more of these conditions apply:
指导方针，考虑在一个或多个条件适用的情况下创建一个结构:&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The structure’s primary purpose is to encapsulate a few relatively simple data values.
结构体的主要目的是封装一些相对简单的数据值。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.
这是当您合理的分配或传递该结构的实例时，封装的值将被复制，而不是被引用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.
结构中存储的任何属性都是值类型，它也可以被复制，而不是被引用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The structure does not need to inherit properties or behavior from another existing type.
结构体不需要从另一个现有类型继承属性或行为。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;优秀的结构体例子包括:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The size of a geometric shape, perhaps encapsulating a width property and a height property, both of type Double.
几何形状的大小，可能是封装了宽度属性和高度属性，两者都是Double类型。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;A way to refer to ranges within a series, perhaps encapsulating a start property and a length property, both of type Int.
一种表示范围内的范围的方法，可能是封装一个起始属性和一个长度属性，这两种类型都是Int类型。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;A point in a 3D coordinate system, perhaps encapsulating x, y and z properties, each of type Double.
In all other cases, define a class, and create instances of that class to be managed and passed by reference. In practice, this means that most custom data constructs should be classes, not structures.
三维坐标系中的一个点，可能是封装x、y和z的属性，每一种类型都是双精度的。
在所有其他情况下，定义一个类，并创建该类的实例，以便通过引用来管理和传递。在实践中，这意味着大多数自定义数据结构应该是类，而不是结构。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;In Swift, many basic data types such as String, Array, and Dictionary are implemented as structures. This means that data such as strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.
在Swift中，许多基本的数据类型，如字符串、数组和字典都是作为结构实现的。这意味着当将字符串、数组和字典等数据分配给新的常量或变量时，或者当它们被传递给函数或方法时，就会复制这些数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This behavior is different from Foundation: NSString, NSArray, and NSDictionary are implemented as classes, not structures. Strings, arrays, and dictionaries in Foundation are always assigned and passed around as a reference to an existing instance, rather than as a copy.
这种行为与Foundation库不同:NSString、NSArray和NSDictionary都是作为类实现的，而不是结构。Foundation中的字符串、数组和字典总是被分配和传递，作为对现有实例的引用，而不是作为副本。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/31/SwiftClassAndStruct.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/31/SwiftClassAndStruct.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift - 函数</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;是的，函数。
总的来说方法和函数并没有什么区别。因为本质相同，都是为了处理独立的工作而存在的。而要说有区别，在以前，函数是面向过程中的概念，方法是面向对象的概念。因为没有类的概念,函数可以直接定义,直接使用。而方法必须在类当中,依托于对象才能执行。
而Swift的统一函数语法足够灵活，可以表达任何东西，从简单的c风格函数，没有参数名，到复杂的objective-c风格的方法，每个参数都有名称和参数标签,既可以独立存在使用,也可以依托于对象,更加灵活和强大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;函数的定义&quot;&gt;函数的定义:&lt;/h1&gt;

&lt;p&gt;func &lt;code class=&quot;highlighter-rouge&quot;&gt;function Name&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;param Name&lt;/code&gt;:&lt;code class=&quot;highlighter-rouge&quot;&gt;param Type&lt;/code&gt;,…) -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;return Type&lt;/code&gt;{
&lt;code class=&quot;highlighter-rouge&quot;&gt;function Body&lt;/code&gt;
 return &lt;code class=&quot;highlighter-rouge&quot;&gt;return Value&lt;/code&gt;;
}&lt;/p&gt;

&lt;p&gt;学习代公式就简单多了。
我们写一个有返回值带参数的函数:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func greet(person: String) -&amp;gt; String {
    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;
    return greeting
}

let name = greet(person: &quot;Jack&quot;)

print(name)
结果:
Hello, Jack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们再写一个没有返回值没有参数的函数:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func greet() {
    print(&quot;nothing&quot;)
}
greet()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就跟组装和拆分玩具一样。&lt;/p&gt;

&lt;h1 id=&quot;函数参数和返回值&quot;&gt;函数参数和返回值&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Function parameters and return values are extremely flexible in Swift. You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.
函数参数和返回值在Swift中非常灵活。您可以定义任何东西，从一个简单的实用函数，到一个不知名的参数，再到具有表达性参数名称和不同参数选项的复杂函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift中的参数是常量,无法直接在函数中修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.函数可以有多个输入参数，这些参数是在函数的圆括号中编写的，用逗号分隔。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func greet(person: String, alreadyGreeted: Bool) -&amp;gt; String {
    let paramValue = &quot;person:&quot;+person+&quot;,alreadyGreeted:&quot;+alreadyGreeted.description;
    return paramValue;
}
print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;官方文档中有这样一种写法:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func printAndCount(string: String) -&amp;gt; Int {
    print(string)
    return string.count
}
func printWithoutCounting(string: String) {
    let _ = printAndCount(string: string)
}
printAndCount(string: &quot;hello, world&quot;)
printWithoutCounting(string: &quot;hello, world&quot;)
结果:
hello, world
hello, world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;简单来说就是在函数中调用其它的函数。在printWithoutCounting函数中,调用printAndCount函数，但却使用缺省值得方式忽略了printAndCount的返回值。这倒是个不错的忽略警告的函数(😀)。&lt;/p&gt;

&lt;p&gt;接下来开始尝试更加复杂的操作,例如下面的🌰是在一组值中获取最大值和最小值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func minMax(array: [Int]) -&amp;gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&amp;lt;array.count] {
        if value &amp;lt; currentMin {
            currentMin = value
        } else if value &amp;gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
let result = minMax(array: [34,53,645,23,12,4,2])
print(&quot;minValue:\(result.min)&quot;)
print(&quot;maxValue:\(result.max)&quot;)
结果:
minValue:2
maxValue:645
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从上述例子中可以引出一个问题,如果返回值为nil怎么办?在这个json数据频繁交互的世界里,有时候数据异常还是比较常见的。而Swift对于数据安全还是很重视的,所以我们将程序修改一下.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func minMax(array: [Int]) -&amp;gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }

    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&amp;lt;array.count] {
        if value &amp;lt; currentMin {
            currentMin = value
        } else if value &amp;gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

let array = Array&amp;lt;Int&amp;gt;();
let result = minMax(array: array)
print(&quot;min is \(result?.min ?? 0) and max is \(result?.max ?? 0)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到我们在minMax函数中添加了对空数组的判断,而这个时候我们就需要用到Swift中的可选类型(Optional?)。
当我们将返回值&lt;code class=&quot;highlighter-rouge&quot;&gt;(min: Int, max: Int)&lt;/code&gt;设定为&lt;code class=&quot;highlighter-rouge&quot;&gt;(min: Int, max: Int)?&lt;/code&gt;的时候,程序本身就会对我们提出很多要求的。如果代码不明确，那么是通不过编译的。例如我们在输出的时候原本的&lt;code class=&quot;highlighter-rouge&quot;&gt;result.min&lt;/code&gt;并没有考虑值为空的情况,最后需要改成&lt;code class=&quot;highlighter-rouge&quot;&gt;result?.min ?? 0&lt;/code&gt;才可以。&lt;/p&gt;

&lt;h1 id=&quot;函数参数标签和参数名&quot;&gt;函数参数标签和参数名&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each function parameter has both an argument label and a parameter name. The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label.
每个函数参数都有一个参数标签和一个参数名。参数标签是在调用函数时使用的;每个参数都在函数调用中使用它的参数标签。在函数的实现中使用了参数名。默认情况下，参数使用参数名作为参数标签。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;公式:
func &lt;code class=&quot;highlighter-rouge&quot;&gt;function Name&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;param label Name&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;param Name&lt;/code&gt;:&lt;code class=&quot;highlighter-rouge&quot;&gt;param Type&lt;/code&gt;,…) -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;return Type&lt;/code&gt;{
&lt;code class=&quot;highlighter-rouge&quot;&gt;function Body&lt;/code&gt;
 return &lt;code class=&quot;highlighter-rouge&quot;&gt;return Value&lt;/code&gt;;
}&lt;/p&gt;

&lt;p&gt;这也算是Swift的特性了,不知道是哪个倒霉孩子写的。
正常写的时候是这样的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func someFunction(firstParameterName: Int, secondParameterName: Int) {
    print(&quot;firstParameterName:&quot;+String(firstParameterName))
    print(&quot;secondParameterName:&quot;+String(secondParameterName))
}
someFunction(firstParameterName: 1, secondParameterName: 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有标签的时候是这样的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func greet(person: String, from hometown: String) -&amp;gt; String {
    return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;
}
print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))
结果:
Hello Bill!  Glad you could visit from Cupertino.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到程序中from是作为调用函数时的参数名称显示的。而hometown也是可以作为参数名称在函数内部使用的。
那大家是不是有疑惑from能不能在函数内部使用？我帮你们试过了，不能使用。也就是说:&lt;strong&gt;标签名不能在函数内部使用&lt;/strong&gt; 
如果非要我来理解这样设计有啥用的话,可能就是为了安全吧。（即使你得到了我的人,但却得不到我的心的赶脚。）&lt;/p&gt;

&lt;h1 id=&quot;省略标签名称&quot;&gt;省略标签名称&lt;/h1&gt;
&lt;p&gt;不得不说 &lt;code class=&quot;highlighter-rouge&quot;&gt;_ &lt;/code&gt; 操作符真是想哪哪都可以省，省出心飞扬。我们还可以借此省略标签。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    print(&quot;firstParameterName:&quot;+String(firstParameterName))
    print(&quot;secondParameterName:&quot;+String(secondParameterName))
}
someFunction(1, secondParameterName: 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们可以在调用的时候就不用写标签名称了。虽然这样可读性不高,毕竟设计标签的时候就是为了可读性。真是上有政策下有对策，这个对策还是上头给的。&lt;/p&gt;

&lt;h1 id=&quot;默认参数值&quot;&gt;默认参数值&lt;/h1&gt;
&lt;p&gt;通过在函数中直接给参数赋值,我们就可以实现参数的默认值。在调用的时候，如果没有传递参数,就可以使用默认值进行操作。这无形给那些经常会遗忘的程序员小哥哥,或者是有默认值情况存在的程序提供了很方便的设计。
让我们来看看具体的🌰：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    print(&quot;firstParameterName:&quot;+String(firstParameterName))
    print(&quot;secondParameterName:&quot;+String(secondParameterName))
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12
结果:
firstParameterName:3
secondParameterName:6
firstParameterName:4
secondParameterName:12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;可变参数&quot;&gt;可变参数&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;variadic parameter accepts zero or more values of a specified type. You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called. Write variadic parameters by inserting three period characters (…) after the parameter’s type name.
可变参数接受指定类型的0或多个值。您可以使用可变参数来指定参数在调用函数时可以传递不同数量的输入值。通过在参数的类型名称后面插入三个周期字符(&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;)来编写可变参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说,你使用&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; 就可以在填写参数的时候随便写多少参数了。妈妈再也不用担心我设计参数的时候太长了。
这里强调的是类型是需要指定的。不过有个Any类型，你也不用怕类型太限制你的想象。
具体的写法可以看下面的🌰:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func arithmeticMean(numbers: Double...) -&amp;gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
print(arithmeticMean(numbers: 1, 2, 3, 4, 5))
print(arithmeticMean(numbers: 3, 8.25, 18.75))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;in---out-参数&quot;&gt;In - Out 参数&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Function parameters are constants by default. Trying to change the value of a function parameter from within the body of that function results in a compile-time error. This means that you can’t change the value of a parameter by mistake. If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.
默认情况下，函数参数是常量。试图从该函数的主体内部更改函数参数的值会导致编译时错误。这意味着您不能错误地更改一个参数的值。如果您想要一个函数来修改一个参数的值，并且您希望在函数调用结束后这些更改继续存在，那么将该参数定义为in-out参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;You write an in-out parameter by placing the inout keyword right before a parameter’s type. An in-out parameter has a value that is passed in to the function, is modified by the function, and is passed back out of the function to replace the original value.
通过在参数类型之前放置inout关键字来编写in-out参数。in-out参数具有传递给函数的值，由函数进行修改，并从函数中返回，以替换原来的值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can only pass a variable as the argument for an in-out parameter. You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified. You place an ampersand (&amp;amp;) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.
您只能传递一个变量作为in-out参数的参数。不能将常数或文字值作为参数传递，因为常量和文本不能被修改。当将变量名作为参数传递给in-out参数时，您可以直接在变量名前面放置一个&amp;amp;(&amp;amp;)，以表明它可以通过函数进行修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官网讲的很清楚了,我们在定义函数参数的时候,参数是常量,那么有些情况可能需要改动参数,就需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;inout&lt;/code&gt; 参数（虽然我感觉重新创建临时变量来获取参数值,替代它进行操作会更好,能够设定不可变的我们尽量不去改变它,可变的操作很容易造成代码编写的散漫性.）&lt;/p&gt;

&lt;p&gt;下面我们举个🌰:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;amp;someInt, &amp;amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这是一个简单的两个数交换的函数.里面的参数a和b都直接参与了计算,如果将inout去除,你会发现程序会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;Cannot assign to value: 'a' is a 'let' constant 不能为a赋值,a 是 let'常量&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;方法类型&quot;&gt;方法类型&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every function has a specific function type, made up of the parameter types and the return type of the function.
每个函数都有一个特定的函数类型，由参数类型和函数的返回类型组成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个概念其实是一直有的。在C或者OC我们可以定义函数指针来获取函数的地址,而我们将该地址赋值给别的函数的时候,就必须保证结构相同,其实也就是数据类型一致了。&lt;/p&gt;

&lt;p&gt;那么如何在Swift中实现呢？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func addTwoInts(_ a: Int, _ b: Int) -&amp;gt; Int {
    return a + b
}

var mathFunction: (Int, Int) -&amp;gt; Int = addTwoInts

print(mathFunction(1,2))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过上面的🌰,应该就知道了吧。设定了函数addTwoInts,类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;(Int,Int)-&amp;gt;Int&lt;/code&gt;,然后直接创建一个同等类型的函数接收它的地址。我们可以通过函数名称直接获取函数相应的地址和数据类型等对应的数据。&lt;/p&gt;

&lt;h1 id=&quot;方法类型作为参数类型&quot;&gt;方法类型作为参数类型&lt;/h1&gt;
&lt;p&gt;在Swift函数中,参数类型也可以说是很灵活了,我们还可以将方法类型直接设定为参数类型。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func addTwoInts(_ a: Int, _ b: Int) -&amp;gt; Int {
    return a + b
}

func printMathResult(mathFunction: (Int, Int) -&amp;gt; Int, _ a: Int, _ b: Int) {
    print(&quot;Result: \(mathFunction(a, b))&quot;)
}

printMathResult(mathFunction: addTwoInts, 3, 5)
结果:
Result: 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的参数mathFunction接收了一个函数addTwoInts.然后直接在函数体中使用了该函数的功能.&lt;/p&gt;

&lt;h1 id=&quot;嵌套函数&quot;&gt;嵌套函数&lt;/h1&gt;
&lt;p&gt;嵌套函数并不算是Swift中独有的,其他的语言中也有很多解决方案。不过这里的嵌套函数,比较直接明了。直接在函数体中定义一个函数来使用,算是一个临时变量,并不能在外界直接被调用。这种设计的好处就是在于自用的函数可以归类在一起,不至于像其他语言那样,散乱的放置在文件当中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func chooseStepFunction(backward: Bool) -&amp;gt; (Int) -&amp;gt; Int {
    func stepForward(input: Int) -&amp;gt; Int { return input + 1 }
    func stepBackward(input: Int) -&amp;gt; Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &amp;gt; 0)

while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}

print(&quot;zero!&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 30 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/30/SwiftMethod.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/30/SwiftMethod.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift - 控制结构</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Swift中的循环语句for,while,dowhile,还有分支switch相比于OC也有很多的改进和变化。这里主要是使用方式了，我们可以快速的过一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;for&quot;&gt;for&lt;/h1&gt;
&lt;p&gt;遍历数组:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let names = [&quot;Anna&quot;,&quot;Alex&quot;,&quot;Brian&quot;,&quot;Jack&quot;];

for name in names{
    print(&quot;Hello,\(name)&quot;)
}

结果:
Hello,Anna
Hello,Alex
Hello,Brian
Hello,Jack

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历字典:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]

for (animalName, legCount) in numberOfLegs {
    print(&quot;\(animalName)s have \(legCount) legs&quot;)
}
结果:
ants have 6 legs
spiders have 8 legs
cats have 4 legs

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;实现范围循环&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index in 1...5 {
    print(&quot;\(index)&quot;, terminator:&quot; &quot;)
}
结果:
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在上面的例子中，index是一个常量，它的值在循环的每次迭代开始时自动设置。因此，索引在使用之前不需要声明。它是通过在循环声明中包含的，而不需要一个let声明关键字来声明的。&lt;/li&gt;
    &lt;li&gt;(…) 可以称之为封闭操作符(closed range operator),这里索引的值被设置为range(1)中的第一个数字，并执行循环中的语句,&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果您不需要一个序列中的每个值，那么可以使用一个下划线代替一个变量名来忽略这些值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
print(&quot;\(base) to the power of \(power) is \(answer)&quot;)

结果:
3 to the power of 10 is 59049
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;简而言之就是 你需要的是一个能够循环x次数的结构,利用它的循环功能做一些事情。而不需要设定一个值来获取它每次循环的值得。这个情况我们在遍历字典的时候也可以用到.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]

for (animalName, _) in numberOfLegs {
    print(&quot;animalName: \(animalName)&quot;)
}
结果:
animalName: ant
animalName: spider
animalName: cat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们只用到它的key或者value,那么就没有必要去再设定一个值了，毕竟自动生成一个临时变量也有开销，虽然很小。&lt;/p&gt;

&lt;p&gt;之前提到了&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID73&quot;&gt;Range Operators&lt;/a&gt;. 它除了之前提到的方式,还可以这样:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let minutes = 60
for tickMark in 0..&amp;lt;minutes {
    print(&quot;\(tickMark)&quot;, terminator: &quot; &quot;)
}

结果:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其实从这一点来说,通过 &lt;strong&gt;range operators&lt;/strong&gt; for in 循环实现将for in与for循环的功能结合起来了,不得不说这样的方式还是很棒的。
当然了,光这样还不能提现出与for循环的结合之后的强大,毕竟for循环可以通过设定参数i,实现i++,i+=5,随心所欲的控制,所以Swift中也设置了这样的方式:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let minuteInterval = 5
let minutes = 60
for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {
    print(tickMark, terminator: &quot; &quot;)
}
结果:
0 5 10 15 20 25 30 35 40 45 50 55
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;stridefromtoby&quot;&gt;stride(from:to:by:)&lt;/h2&gt;
&lt;p&gt;Swift的方法定义还是很有好的,只要会点英文还是能看得懂的,from:开始的数值, to:结束的数值,by:每次循环的步数&lt;/p&gt;

&lt;p&gt;除了以上方法之外,还有另一个方法:&lt;/p&gt;

&lt;h2 id=&quot;stridefromthroughby&quot;&gt;stride(from:through:by:)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let minuteInterval = 5
let minutes = 15
for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {
    print(tickMark, terminator: &quot; &quot;)
}
print(&quot;&quot;)
for tickMark in stride(from: 0, through: minutes, by: minuteInterval) {
    print(tickMark, terminator: &quot; &quot;)
}
结果:
0 5 10 
0 5 10 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么这个方法是干什么的呢? 从结果来说,我们应该已经明白了,其实就是 stride(from:to:by:) 设定的结果范围我们是不包括的,而stride(from:through:by:) 中参数through设定的结果值范围是包括的。&lt;/p&gt;

&lt;h1 id=&quot;while&quot;&gt;While&lt;/h1&gt;
&lt;p&gt;while与OC中并没有什么区别,但是却多出了一个repeat-while&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;repeat {
    statements
} while condition
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其实吧,这个跟do-while没啥区别,因为do关键字在Swift被设定为捕捉异常了。&lt;/p&gt;

&lt;h1 id=&quot;switch&quot;&gt;Switch&lt;/h1&gt;
&lt;p&gt;switch相比于OC,或者说绝大多数语言来说都要强大了,因为switch-case分支支持的类型更加多了.
曾经只有整型,字符串,字符才可以，如今还加入了很多不一样的组合:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let anotherCharacter: Character = &quot;a&quot;

switch anotherCharacter {
case &quot;a&quot;, &quot;A&quot;:
    print(&quot;The letter A&quot;)
default:
    print(&quot;Not the letter A&quot;)
}
结果:
The letter A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在判断的时候,我们将类似集合的方式写入设定在case分支上了,这样就避免了冗长的判断,还有更加灵活的写法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let approximateCount = 62
let countedThings = &quot;moons orbiting Saturn&quot;
let naturalCount: String
switch approximateCount {
case 0:
    naturalCount = &quot;no&quot;
case 1..&amp;lt;5:
    naturalCount = &quot;a few&quot;
case 5..&amp;lt;12:
    naturalCount = &quot;several&quot;
case 12..&amp;lt;100:
    naturalCount = &quot;dozens of&quot;
case 100..&amp;lt;1000:
    naturalCount = &quot;hundreds of&quot;
default:
    naturalCount = &quot;many&quot;
}
print(&quot;There are \(naturalCount) \(countedThings).&quot;)
结果:
There are dozens of moons orbiting Saturn.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以是范围,也可以是数组:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print(&quot;\(somePoint) is at the origin&quot;)
case (_, 0):
    print(&quot;\(somePoint) is on the x-axis&quot;)
case (0, _):
    print(&quot;\(somePoint) is on the y-axis&quot;)
case (-2...2, -2...2):
    print(&quot;\(somePoint) is inside the box&quot;)
default:
    print(&quot;\(somePoint) is outside of the box&quot;)
}
结果:
(1, 1) is inside the box
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;_-通配符模式以匹配任何可能的值&quot;&gt;_ 通配符模式，以匹配任何可能的值。&lt;/h2&gt;

&lt;p&gt;switch 还设定了一种&lt;strong&gt;值绑定(Value Bindings)&lt;/strong&gt;的方式来匹配case分支&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print(&quot;on the x-axis with an x value of \(x)&quot;)
case (0, let y):
    print(&quot;on the y-axis with a y value of \(y)&quot;)
case let (x, y):
    print(&quot;somewhere else at (\(x), \(y))&quot;)
}
结果:
on the x-axis with an x value of 2

let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print(&quot;On an axis, \(distance) from the origin&quot;)
default:
    print(&quot;Not on an axis&quot;)
}
结果:
On an axis, 9 from the origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么什么是&lt;strong&gt;值绑定&lt;/strong&gt;呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body.
switch case可以将它匹配的值或值命名为临时常量或变量，以便在案例的主体中使用。这种行为被称为值绑定，因为值被绑定到在case的主体内的临时常量或变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;拿上述例子来说,我们设置了(2,0),于之匹配的case是(let x,0),这时候，就会将2赋值给常量x,那么在这个case分支中，我们就可以使用该常量x进行一些操作了。简单来说就是将2与常量x进行了绑定。&lt;/p&gt;

&lt;p&gt;除了以上设定之外,switch还可以通过&lt;strong&gt;where&lt;/strong&gt;关键来设定case分支:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print(&quot;(\(x), \(y)) is on the line x == y&quot;)
case let (x, y) where x == -y:
    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
case let (x, y):
    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
}
结果:
(1, -1) is on the line x == -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;where 关键字用于条件判断,let (x, y) where x == y 例如此处的运算时如果x == y 那么执行 let (x, y)&lt;/p&gt;

&lt;h1 id=&quot;control-transfer-statements&quot;&gt;Control Transfer Statements&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;continue&lt;/li&gt;
  &lt;li&gt;break&lt;/li&gt;
  &lt;li&gt;return&lt;/li&gt;
  &lt;li&gt;throw&lt;/li&gt;
  &lt;li&gt;fallthrough&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前四个都是比较常见的&lt;/p&gt;

&lt;h2 id=&quot;continue是忽略循环中的单次执行&quot;&gt;continue是忽略循环中的单次执行&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index in 1...5{
    if index == 2{
        continue
    }
    print(&quot;\(index)&quot;, terminator:&quot; &quot;)
}

结果:
1 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;break&quot;&gt;break&lt;/h2&gt;
&lt;p&gt;结束当前循环,也就是说，如果是多重循环嵌套,结束的只是其中一个循环而已,并不会结束所有循环&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index in 1...5{
    if index == 2{
        break
    }
    print(&quot;\(index)&quot;, terminator:&quot; &quot;)
}
结果:
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;return&quot;&gt;return&lt;/h2&gt;
&lt;p&gt;return 如果方法中具有返回值,需要再return后面设定返回值,如果没有返回值,那么其实返回的是nil. 也就是return是作用在方法中的，所以它会直接结束,不会再继续运行接下来的代码了。具体在方法中演示。&lt;/p&gt;

&lt;h2 id=&quot;throw&quot;&gt;throw&lt;/h2&gt;
&lt;p&gt;是当发生错误的时候,手动的在相应的位置抛出异常。具体的我们再异常中演示&lt;/p&gt;

&lt;h2 id=&quot;fallthrough&quot;&gt;fallthrough&lt;/h2&gt;
&lt;p&gt;这个其实就比较有意思了,因为可以看出Swift在设计时的用心程度。为什么这么说呢?&lt;/p&gt;

&lt;p&gt;我们曾经是这样写的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (result){
  case 1:
     XXX
    break;
  case 2:
     XXX
   case3:
     XXX
    break;
default:
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每个case分支需要利用break来分割成个体,要想顺序执行需要将break去掉，像case2,case3那样.而swift中默认是不需要break,直接就是个体执行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (result){
  case 1:
     XXX
  case 2:
     XXX
  case 3:
     XXX
default:
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那这样的话是不是感觉就不好顺序执行了?当然不是了,这时候&lt;strong&gt;fallthrough&lt;/strong&gt;的作用就出来了:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let integerToDescribe = 5

switch integerToDescribe {
case 5:
     print(&quot;integerToDescribe:\(integerToDescribe)&quot;)
    fallthrough
case 1:
     print(&quot;1&quot;)
default:
     print(&quot;other&quot;)
}
结果:
integerToDescribe:5
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;利用fallthrough我们就可以让两个case联系起来了。
这个就是简单将多余的需求去除,变得更加贴切我们的实际使用。正常使用中将case联合起来的情况就跟你在大街上遇到刘亦菲跟你说hello一样困难。所以为啥我们每次都要多写那该死的break呢,用到加个fallthrough不就好了嘛。&lt;/p&gt;

&lt;h2 id=&quot;labeled-statements&quot;&gt;Labeled Statements&lt;/h2&gt;
&lt;p&gt;翻译过来是标签声明,这个是什么意思呢？官网的比较晦涩难懂,我们用实践来初步了解一下:
首先它是这样一个结构:
&lt;code class=&quot;highlighter-rouge&quot;&gt;label name&lt;/code&gt;: while &lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt; {
    &lt;code class=&quot;highlighter-rouge&quot;&gt;statements&lt;/code&gt;
}&lt;/p&gt;

&lt;p&gt;那么这个标签有啥特殊的地方呢?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var index = 10

while index &amp;lt; 20 {
    switch index {
    case 11:
        print(&quot;11&quot;)
        break
    case 12:
        print(&quot;12&quot;)
    default:
        break
    }
    index+=1
}

结果:
11
12

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们改一下程序,将标签gameloop设置到程序当中:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var index = 10

gameloop: while index &amp;lt; 20 {
    switch index {
    case 11:
        print(&quot;11&quot;)
        break gameloop
    case 12:
        print(&quot;12&quot;)
    default:
        break
    }
    index+=1
}
结果:
11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过结果还有官网的说明来看:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures. However, loops and conditional statements can both use the break statement to end their execution prematurely. Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a break statement to terminate. Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the continue statement should affect.&lt;/li&gt;
    &lt;li&gt;To achieve these aims, you can mark a loop statement or conditional statement with a statement label. With a conditional statement, you can use a statement label with the break statement to end the execution of the labeled statement. With a loop statement, you can use a statement label with the break or continue statement to end or continue the execution of the labeled statement.&lt;/li&gt;
    &lt;li&gt;在Swift中，您可以在其他循环和条件语句中嵌套循环和条件语句，以创建复杂的控制流结构。但是，循环和条件语句都可以使用break语句来提前结束它们的执行。因此，有时需要显式地明确哪些循环或条件语句，您想要一个break语句终止。类似地，如果您有多个嵌套循环，那么可以很清楚地说明continue语句应该影响哪些循环。&lt;/li&gt;
    &lt;li&gt;为了实现这些目标，您可以用一个语句标签来标记一个循环语句或条件语句。使用条件语句，您可以使用break语句的语句标签来结束标记语句的执行。使用循环语句，您可以使用带有中断或continue语句的语句标签来结束或继续执行标记的语句。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说就是标签运用于多中控制结构的情况,可以清晰的知道我们在控制结构中设置的某些控制节点的存在。算是比较灵活。&lt;/p&gt;

&lt;p&gt;最后的是检查版本或者API情况
if #available(&lt;code class=&quot;highlighter-rouge&quot;&gt;platform name&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;, *) {
    &lt;code class=&quot;highlighter-rouge&quot;&gt;statements to execute if the APIs are available&lt;/code&gt;
} else {
  &lt;code class=&quot;highlighter-rouge&quot;&gt;fallback statements to execute if the APIs are unavailable&lt;/code&gt;
}&lt;/p&gt;

&lt;p&gt;以往我们在判断版本的时候需要用到宏定义去判断,现在嘛，有现成的判断方法了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/29/SwiftControl-structure.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/29/SwiftControl-structure.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift - 集合 - Set and Dictionary</title>
        <description>&lt;h1 id=&quot;set&quot;&gt;Set&lt;/h1&gt;
&lt;p&gt;Set 也是集合的一种,很多方法与Array类似,但似仍然具有一些Array不具备的特性。&lt;/p&gt;

&lt;p&gt;Set具有无序且不重复的特性.我们在创建的时候,设定的值是:&lt;code class=&quot;highlighter-rouge&quot;&gt;1,2,3&lt;/code&gt;,但是出来的结果有可能是&lt;code class=&quot;highlighter-rouge&quot;&gt;2,3,1&lt;/code&gt;,也有可能是&lt;code class=&quot;highlighter-rouge&quot;&gt;3,1,2&lt;/code&gt;。其值并不像Array那样井然有序。&lt;/p&gt;

&lt;p&gt;我们首先来创建一个空的Set&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let numSet = Set&amp;lt;String&amp;gt;()
print(numSet)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Set&lt;type&gt; 对于Swift的安全性来说,创建的时候没有数据用来推导数据类型的话,我们就要指定类型了.
Set 指定了数据类型之后，也就意味着,它的值就必须是该类型，这一点与其它的集合类型都是一致的。&lt;/type&gt;&lt;/p&gt;

&lt;p&gt;创建一个具有数据的Set集合&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let numSet = Set(arrayLiteral: 1,3,4)
let wordSet:Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
let wordTypeSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;set的内置方法&quot;&gt;Set的内置方法&lt;/h1&gt;
&lt;h2 id=&quot;insert-插入&quot;&gt;insert 插入&lt;/h2&gt;
&lt;p&gt;Set中想加入一个新元素,无法使用apped,要使用insert进行插入新的元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numSet = Set&amp;lt;String&amp;gt;()
numSet.insert(&quot;A&quot;)
print(numSet)
结果:
[&quot;A&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;update&quot;&gt;update&lt;/h2&gt;
&lt;p&gt;也可以通过update的方式将新元素更新到Set中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var wordSet:Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
wordSet.update(with: &quot;D&quot;)
print(wordSet)
结果:
[&quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;D&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Set中,我们有以下四个办法高效地执行基本的集操作，例如将两个集合组合在一起，确定两个集合具有相同的值，或者确定两个集合是否包含所有、一些或没有相同的值。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-7a104e4770532e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540&quot; alt=&quot;setVennDiagram_2x.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ntersection&quot;&gt;ntersection&lt;/h2&gt;
&lt;p&gt;交集,获取两个集合中都具有的元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var oldSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
var newSet:Set&amp;lt;String&amp;gt; = [&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]
let tempSet  =  oldSet.intersection(newSet)
print(tempSet)
结果:
[&quot;C&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;symmetricdifference&quot;&gt;symmetricDifference&lt;/h2&gt;
&lt;p&gt;将两个集合结合起来，但排除了两者都有的元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var oldSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
var newSet:Set&amp;lt;String&amp;gt; = [&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]
let tempSet  = oldSet.symmetricDifference(newSet);
print(tempSet)
结果:
[&quot;B&quot;, &quot;A&quot;, &quot;D&quot;, &quot;E&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;union&quot;&gt;union&lt;/h2&gt;
&lt;p&gt;将两个集合连接起来,去除重复的数据.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var oldSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
var newSet:Set&amp;lt;String&amp;gt; = [&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]
let tempSet  = oldSet.union(newSet);
print(tempSet)
结果:
[&quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;subtracting&quot;&gt;subtracting&lt;/h2&gt;
&lt;p&gt;创建一个没有在指定集中的值的新集合。
看一下结果对比:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;结果一:
var oldSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
var newSet:Set&amp;lt;String&amp;gt; = [&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
let tempSet  = oldSet.subtracting(newSet);
print(tempSet)
结果:
[&quot;C&quot;, &quot;B&quot;, &quot;A&quot;]

结果二:
var oldSet:Set&amp;lt;String&amp;gt; = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
var newSet:Set&amp;lt;String&amp;gt; = [&quot;C&quot;,&quot;B&quot;,&quot;F&quot;]
let tempSet  = oldSet.subtracting(newSet);
print(tempSet)
结果:
[&quot;A&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过结果我们可以分析出:
这个方法其实就是oldSet集合排除了另一个集合的元素之后，剩下的元素会组成一个新集合。&lt;/p&gt;

&lt;h1 id=&quot;set中的判断&quot;&gt;Set中的判断&lt;/h1&gt;
&lt;p&gt;在Set中，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; 来判断两个集合是否相等:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let firstSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;];
let secondSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;];
let thirdSet: Set = [&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
print(&quot;firsSet is equal secondSet : \(firstSet == secondSet)&quot;)
print(&quot;firsSet is equal thirdSet : \(firstSet == thirdSet)&quot;)
结果:
firsSet is equal secondSet : true
firsSet is equal thirdSet : false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;issubset&quot;&gt;isSubSet&lt;/h2&gt;
&lt;p&gt;用此方法确定一个集合的所有值是否包含在指定的集合中。
也就是说，前者是否是后者的子集&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let firstSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;];
let secondSet: Set = [&quot;D&quot;,&quot;E&quot;,&quot;F&quot;];
let thirdSet: Set = [&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
print(secondSet.isSubset(of: firstSet))
print(thirdSet.isSubset(of: firstSet))
结果:
false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;issuperset&quot;&gt;isSuperSet&lt;/h2&gt;
&lt;p&gt;用此确定一个集合是否包含了一个指定集合中的所有值。
也就是,前者是否是后者的超集&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let firstSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;];
let secondSet: Set = [&quot;D&quot;,&quot;E&quot;,&quot;F&quot;];
let thirdSet: Set = [&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
print(firstSet.isSuperset(of: secondSet))
print(firstSet.isSuperset(of: thirdSet))
结果:
false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;可以用isstrictsubset或者isstrictsuperset&quot;&gt;可以用isStrictSubset或者isStrictSuperset&lt;/h2&gt;
&lt;p&gt;来确定一个集合是一个子集还是超集，但不等于一个指定的集合。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let firstSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;];
let secondSet: Set = [&quot;D&quot;,&quot;E&quot;];
let thirdSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;];
print(secondSet.isStrictSubset(of: firstSet))
print(thirdSet.isStrictSubset(of: firstSet))
print(firstSet.isStrictSuperset(of: secondSet))
print(firstSet.isStrictSuperset(of: thirdSet))
结果:
true
false
true
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;简单来说的话, isStrictSubset或者isStrictSuperset 相比较于isSubSet和isSuperSet,多了一个是否等于超集的判断。&lt;/p&gt;

&lt;h2 id=&quot;isdisjoint&quot;&gt;isDisjoint&lt;/h2&gt;
&lt;p&gt;用此确定两个集合是否没有共同的值。如果包含返回false,不包含返回true&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let firstSet: Set = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,];
let secondSet: Set = [&quot;D&quot;,&quot;E&quot;];
let thirdSet: Set = [&quot;A&quot;,&quot;B&quot;];
print(firstSet.isDisjoint(with:secondSet))
print(firstSet.isDisjoint(with:thirdSet))
结果:
true
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;dictionary-字典&quot;&gt;Dictionary 字典&lt;/h1&gt;
&lt;p&gt;字典是一种以键值对的方式存在的集合。键是唯一的,不能重复。同样也是无序的集合。
[&lt;code class=&quot;highlighter-rouge&quot;&gt;key 1&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;value 1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;key 2&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;value 2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;key 3&lt;/code&gt;:&lt;code class=&quot;highlighter-rouge&quot;&gt; value 3&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;我们来试着创建一个空的字典&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dict = [String:String]()
或者这样
let dict:[Int:String] = [:]
也可以这样
let dict = Dictionary&amp;lt;String,String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们创建一个有值得字典:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;] 
print(dict)
结果:
[&quot;name&quot;: &quot;啊威&quot;, &quot;age&quot;: &quot;18&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;更快捷的方法:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dict = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;] 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在实际的时候，我们value的数据类型可能并不统一,而Swift对于类型的要求却很严格,所以我们需要另一种定义的方式:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:18]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当我们这样做的时候,系统会报出这样的错误:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Heterogeneous collection literal could only be inferred to '[String : Any]';
 add explicit type annotation if this is intentional
异构集合文字只能被推断为“String:Any”;如果这是有意的，添加显式类型注释
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们不能隐式的这样写,系统要求我们显式地写出来&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:18] as [String : Any]
print(dict)
结果:
[&quot;name&quot;: &quot;啊威&quot;, &quot;age&quot;: 18]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到18的类型并不是String了。因为我们标注的类型是String和Any(任何类型)&lt;/p&gt;

&lt;p&gt;那么,如何直接设置键的值呢?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
dict[&quot;age&quot;] = &quot;25&quot;
print(dict[&quot;age&quot;] ?? &quot;0&quot;)
结果：
25
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们通过这样的方式来设置字典的值。
也可以这样做&lt;/p&gt;

&lt;h2 id=&quot;updatevaluevalueforkeykey&quot;&gt;updateValue(value,forKey:key)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
dict.updateValue(&quot;23&quot;, forKey: &quot;age&quot;)
print(dict[&quot;age&quot;] ?? &quot;0&quot;)
结果:
23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;popfirst-获取第一对键值&quot;&gt;popFirst 获取第一对键值&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
print(dict.popFirst() ?? &quot;&quot;)
print(dict.popFirst()?.key ?? &quot;&quot;)
结果:
(key: &quot;name&quot;, value: &quot;啊威&quot;)
age
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;keysvalues-分别获取字典的全部键和全部值&quot;&gt;keys,values 分别获取字典的全部键和全部值&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
let dictKeys = [String](dict.keys)
print(dictKeys)
let dictValues = [String](dict.values)
print(dictValues)
结果:
[&quot;name&quot;, &quot;age&quot;]
[&quot;啊威&quot;, &quot;18&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removevalueforkey-根据提供的key移除key和value&quot;&gt;removeValue(forKey:) 根据提供的key移除key和value&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
let removedValue = dict.removeValue(forKey: &quot;name&quot;)!
print(&quot;removed value is : \(removedValue)&quot;)
print(dict)
结果:
removed value is : 啊威
[&quot;age&quot;: &quot;18&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removeatindex-根据提供的下标进行删除&quot;&gt;remove(at:index) 根据提供的下标进行删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
dict.remove(at: dict.startIndex)
print(dict)
结果:
[&quot;age&quot;: &quot;18&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;字典的遍历&quot;&gt;字典的遍历&lt;/h1&gt;
&lt;p&gt;字典的遍历与其他集合不同的主要在于有键值的明显区分,所以我们可以以下的方式去遍历:&lt;/p&gt;

&lt;h2 id=&quot;获取字典的键和值&quot;&gt;获取字典的键和值:&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]

for (name,age) in dict{
    print(&quot;\(name):\(age)&quot;)
}
结果:
name:啊威
age:18
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;获取每一对键值结果&quot;&gt;获取每一对键值结果:&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dict:Dictionary = [&quot;name&quot;:&quot;啊威&quot;,&quot;age&quot;:&quot;18&quot;]
for name in dict{
    print(&quot;\(name)&quot;)
}
结果:
(key: &quot;name&quot;, value: &quot;啊威&quot;)
(key: &quot;age&quot;, value: &quot;18&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 15 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/15/SwiftSetand-Dictionary.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/15/SwiftSetand-Dictionary.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift - 数组和集合</title>
        <description>&lt;p&gt;在Swift中仍然保留了OC中的三种集合类型:
Array:数组是有序的值集合。
Set:集合是惟一值的无序集合。
Dictionary:字典是键值关联的无序集合。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-0bda4fc9895f9fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640&quot; alt=&quot;CollectionTypes.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection.
在Swift中，数组、集合和字典的值得数据类型很明确。这意味着您不能将错误类型的值插入到集合中。
它还意味着您可以对从集合中检索到的值类型有信心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift’s array, set, and dictionary types are implemented as generic collections.
Swift的数组、集合和字典类型被实现为泛型集合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be mutable. This means that you can change (or mutate) the collection after it’s created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed.
如果您创建一个数组、一个集合或一个字典，并将其赋值给一个变量，那么所创建的集合将是可变的。这意味着您可以通过在集合中添加、删除或更改项目来更改(或更改)集合。如果您将数组、集合或字典赋值给常量，那么该集合是不可变的，它的大小和内容不能被更改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到了官网对于Swift中集合的各种特性解释，接下来我们进入实践阶段,来验证它是否是这样的。&lt;/p&gt;
&lt;h1 id=&quot;arrays&quot;&gt;Arrays&lt;/h1&gt;
&lt;h2 id=&quot;arrays的初始化&quot;&gt;Arrays的初始化&lt;/h2&gt;
&lt;p&gt;在创建之初,我们首先要想好,是需要可变的还是不可变的。
一般来说我们使用不可变的会增加我们程序的安全性,避免了我们在编写程序时无意中添加或者删除了某值造成不好的效果,但系统却没有给出相应的提示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someNumber = [3,42,5]
print(someNumber)
结果:
[3, 42, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这一段程序中,我们直接将3,42,5三个int类型的值加入到了someNumber数组中去了。
在这过程中swift还需要动态的去判断值的类型。
所以我们也可以直接指定它的数据类型:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someNumber:[Int] = [3,42,5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的一个好处就是我们可以很容易的去识别一个数组当中值得类型是否正确:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someNumber:[Int] = [3,&quot;Str&quot;,5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当你这样写的时候,编译就会发生错误,因为”Str”是String类型并不是Int类型,程序就会及时的给予你提示。&lt;/p&gt;

&lt;p&gt;然而上面的方式其实是一种简写的方式,完整的写法应该如下所示:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someInts = [Int](arrayLiteral: 3,3,5)
print(someInts)

let arrayInts = Array(arrayLiteral: &quot;3&quot;,&quot;3&quot;,&quot;3&quot;)
print(arrayInts)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再看其他的初始化方式:
创建一个空的数组&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var someInts = [Int]()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里要注意的就是[Int]它的数据类型不能省.不然会报错。
因为Swift中严格的数据类型控制。可以设想,这里没有数据类型控制的话,那么我们在之后的追加元素的操作中,
追加了不同的数据,而我们之前又没有显示的去设定它的数据类型，就会造成数据类型不可控的情况,这个在Swift并不被允许。
你可以通过append去追加元素(当然了,首先你的数组是个变量,而不是常量):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;someInts.append(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时,如果你已经初始化完毕,那么你可以直接设定你的数组为空:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;someInts = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;你可能会有疑问,为什么一开始的时候不能这样设置为空呢？
因为在这里虽然你设为了空,someInts的数据类型还是Int,你仍然是无法去添加其他类型的值的。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var someInts = [Int]()
someInts.append(3)
someInts = []
someInts.append(&quot;string&quot;)  //error:Cannot convert value of type 'String' to expected argument type 'Int'
print(someInts)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再看看其它的初始化方式:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let threeDoubles = Array(repeatElement(0.0, count: 3))
print(threeDoubles)
结果:
[0.0, 0.0, 0.0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其实从参数名称上我们就可以知道,我们创建了3个重复值用于数组的初始化。
repeatElement方法中可以填写两个参数,一个是需要重复的数据,count表示重复多少次。
我想,这是为了方便我们在特定情况下的初始化吧。&lt;/p&gt;

&lt;p&gt;嗯,继续看看别的初始化方式:
我们在使用的时候,默认的数据的类型的确是确保了我们的数据类型安全,但同时也限制了我们编程的灵活性。
在很多实际的运用场景中,一个数组集合中包含的并不可能只有一种数据类型的值,如果每一种都需要定义个数组来进行操作的话,也会增加开发成本。当然咯，这个还是根据具体的环境来决定成本的舍取性的。
那么如何去定义一个什么类型都可以存的数组呢？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let anyData = [&quot;String&quot;,34,53] as [Any]
print(anyData)
结果:
[&quot;String&quot;, 34, 53]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过结果我们可以看到,这样定义的数组可以容纳其他类型的值。&lt;/p&gt;

&lt;p&gt;初始化我们大概了解了之后,我们还需要了解它的内置方法:&lt;/p&gt;

&lt;h1 id=&quot;array的内置方法&quot;&gt;Array的内置方法&lt;/h1&gt;
&lt;h2 id=&quot;first-获取第一个元素&quot;&gt;first 获取第一个元素&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
print(shopping_list.first)
结果:
&quot;A&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;first-where-根据判断条件返回结果&quot;&gt;first where 根据判断条件返回结果&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [53,4,2,45]
let result = shopping_list.first(where: { (intResult) -&amp;gt; Bool in
    return intResult==54
})
print(result ?? 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的意思是如果第一个元素是54,那么返回正确结果,如果不是的话本来是应该返回nil的，但是我们给它做了判断,如果为nil,那么结果为0。&lt;/p&gt;

&lt;h2 id=&quot;last-获取最后一个元素&quot;&gt;last 获取最后一个元素&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
print(shopping_list.last)
结果:
&quot;D&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;count-数量&quot;&gt;count 数量&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let shopping_list = [3,4,2,3]
print(&quot;The shopping_list list contains \(shopping_list.count) items.&quot;)
结果:
The shopping_list list contains 4 items.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;isempty-判空&quot;&gt;isEmpty 判空&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let shopping_list = [3,4,2,3]

if shopping_list.isEmpty {
    print(&quot;The shopping_list list is empty.&quot;)
} else {
    print(&quot;The shopping_list list is not empty.&quot;)
}
结果:
The shopping_list list is not empty.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;contains-判断数组中是否包含某个元素&quot;&gt;contains 判断数组中是否包含某个元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
print(shopping_list.contains(&quot;C&quot;))
结果:
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;append-追加&quot;&gt;append 追加&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1]
shopping_list.append(4)
print(shopping_list)
结果:
[1,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;insertnewelement--at--插入单个元素&quot;&gt;insert(newElement:  at: ) 插入单个元素&lt;/h2&gt;
&lt;p&gt;将新元素插入到指定的位置,但不能插入到数组最后一位的下一位。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1]
shopping_list .insert(3, at: 1)
print(shopping_list)
结果:
[1,3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;insertcontentsofat-插入整个集合&quot;&gt;insert(contentsOf:at:) 插入整个集合&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2]
var otherShopping_list = [3,4,5]
shopping_list.insert(contentsOf: otherShopping_list, at: 2)
print(shopping_list)
结果:
[1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;replacesubrangerange-with-collection-将某个范围的元素替换为指定的集合&quot;&gt;replaceSubrange(Range&lt;Int&gt;, with: Collection) 将某个范围的元素替换为指定的集合&lt;/Int&gt;&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
shopping_list.replaceSubrange(0...1,with:[&quot;F&quot;,&quot;E&quot;])
print(shopping_list)
结果:
 [&quot;F&quot;,&quot;E&quot;,&quot;C&quot;,&quot;D&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removeat-移除某个下标的元素&quot;&gt;remove(at:) 移除某个下标的元素&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.remove(at: 0)
print(shopping_list)
结果:
[2,3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removefirstcount-从开始位置开始移除指定数量的元素&quot;&gt;removeFirst(count) 从开始位置开始移除指定数量的元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.removeFirst(2)
print(shopping_list)
结果:
[3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removelastcount-从末尾位置开始向前移除指定数量的元素&quot;&gt;removeLast(count) 从末尾位置开始向前移除指定数量的元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.removeLast(2)
print(shopping_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removefirst-移除第一个元素&quot;&gt;removeFirst() 移除第一个元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.removeFirst()
print(shopping_list)
结果:
[2,3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;removelast-移除最后一个元素&quot;&gt;removeLast() 移除最后一个元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.removeLast()
print(shopping_list)
结果:
[1,2,3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;removesubrangerange-移除某个范围内的元素&quot;&gt;removeSubrange(Range) 移除某个范围内的元素&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list.removeSubrange(0...1)
print(shopping_list)
结果:
[3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;0…1 表示 [0,1] 的区间,即包含0和1的范围&lt;/p&gt;

&lt;h2 id=&quot;removeall-移除所有&quot;&gt;removeAll() 移除所有&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
shopping_list. removeAll()
print(shopping_list)
结果:
[]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;移除数组中全部元素，有一个可选参数，keepCapacity。如果keepCapacity = YES的话，那么数组移除元素后，其存储空间还是存在的，在此往里存储值，不需再给他分配存储空间了。如果keepCapacity=NO的话，那么数组的存储空间就会被回收掉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shopping_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shopping_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;keepCapacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shopping_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;结果&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;数组的遍历&quot;&gt;数组的遍历&lt;/h1&gt;
&lt;p&gt;比较常见的就是for-loop遍历了。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [1,2,3,4]
for item in shopping_list {
    print(item, terminator: &quot;&quot;)
}
结果:
1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一种方式是枚举遍历法,我们有时也会称之为迭代器遍历&lt;/p&gt;

&lt;p&gt;官网中这样解释到:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;If you need the integer index of each item as well as its value, use the enumerated() method to iterate over the array instead. For each item in the array, the enumerated() method returns a tuple composed of an integer and the item. The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices. You can decompose the tuple into temporary constants or variables as part of the iteration:
如果您需要这个项目的每一个值和索引，那么可以使用enumerated()方法来迭代该数组。对于数组中的每个项，enumerated()方法返回一个由一个整数和项组成的元组。整数从零开始，每一项都是一;如果您对整个数组进行枚举，那么这些整数将匹配项目的索引。您可以将元组分解为临时常量或变量，作为迭代的一部分:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
let enumerated_list = shopping_list.enumerated()
for (index, value) in  enumerated_list {
    print(&quot;Item \(index + 1): \(value)&quot;)
}
结果:
Item 1: A
Item 2: B
Item 3: C
Item 4: D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中可以看到index就是它的索引,value是它的值。&lt;/p&gt;

&lt;h2 id=&quot;sorted-排序&quot;&gt;sorted 排序&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [53,4,2,45]
for item in shopping_list.sorted(){
    print(item,terminator: &quot; &quot;)
}
结果:
2 4 45 53 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sorted-by-有条件的排序&quot;&gt;sorted by 有条件的排序&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var shopping_list = [53,4,2,45]
shopping_list = shopping_list.sorted { (old, new) -&amp;gt; Bool in
    return old&amp;lt;new;
}
print(shopping_list)
如果old&amp;lt;new为升序:
[2, 4, 45, 53]
old&amp;gt;new为降序:
[53, 45, 4, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 13 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/13/swiftStringAndCharacter-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/13/swiftStringAndCharacter-2.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift - 字符串和字符</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Swift的字符串类型与Foundation的NSString类连接。Foundation还扩展了字符串来公开由NSString定义的方法。这意味着，如果您导入Foundation，您可以在字符串中访问这些NSString方法，而不需要进行强制转换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;单行字符串&quot;&gt;单行字符串&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; let someString = &quot;Some stirng&quot; &lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;多行文本&quot;&gt;多行文本&lt;/h1&gt;
&lt;p&gt;多行文本使用 `  “”” 内容 “”” `  没错，就是三个引号开头，三个引号结尾。
多行字符串文字包含了它的起始引号和结束引号之间的所有行&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lyric&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
那是你的眼神，明亮又美丽
啊啊啊~~~
&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lyric&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;结果&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;那是你的眼神&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;明亮又美丽&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;啊啊啊&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;好吧，这个我一开始以为只是在格式上可以写成多行，没想到结果就是多行，效果等同于\n,而且这样写法更加方便。
还有就是当我们想在多行文本中想控制某行不换行，可以选择在某行的末尾写上 \ 那么下一行就不会换行了&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lyric&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
那是你的眼神，明亮又美丽&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;
啊啊啊~~~
&quot;&quot;&quot;&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;结果&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;那是你的眼神&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;明亮又美丽啊啊啊&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~~~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在多行文本中，我们可以在结束引号的前面设定空格，来限定整段文本的缩进:&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lyric&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
  那是你的眼神，明亮又美丽
  啊啊啊~~~

  &quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面例子中,我们在最后”&quot;”前设定了2个空格,那么之前的文本必须都是缩进2个空格如果你这样写:&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lyric&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
那是你的眼神，明亮又美丽
啊啊啊~~~

  &quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;你会发现会报错&lt;code class=&quot;highlighter-rouge&quot;&gt;Insufficient indentation of line in multi-line string literal 多行字符串文字的行缩不足&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;字符串中特殊字符&quot;&gt;字符串中特殊字符&lt;/h2&gt;
&lt;p&gt;\(反斜杠)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let test = &quot;====\\====&quot;
结果:
====\====
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;\t(水平选项卡)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let test = &quot;\t1\t2\t3&quot;
结果:
	1	2	3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;\n(换行符)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let test = &quot;\n1\n2\n3&quot;
结果:

1
2
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;\r(回车)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let test = &quot;\r1\r2\r3&quot;
结果:

1
2
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从结果来看,\r和\n似乎没有区别,但既然存在即表示肯定是有区别的&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;‘\r’是回车，\r 使光标到行首. ‘\n’是换行，\n 使光标下移一格,通常敲一个回车键，即是回车，又是换行（\r\n）。Unix中每行结尾只有“&lt;换行&gt;”，即“\n”；Windows中每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”；Mac中每行结尾是“&lt;回车&gt;”&lt;/回车&gt;&lt;/回车&gt;&lt;/换行&gt;&lt;/换行&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般遇到的情况是在解析Json字符串,网页数据,文件信息的时候会出现不同的应对.&lt;/p&gt;

&lt;p&gt;&quot;(双引号)&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;认识自己的无知是认识世界的最可靠的方法。——《随笔集》&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;结果&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;认识自己的无知是认识世界的最可靠的方法。——《随笔集》&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;'(单引号)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let test = &quot;\'曦\'&quot;
结果:
'曦'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Unicode 字符就直接采用官网的了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dollarSign = &quot;\u{24}&quot;        // $,  Unicode scalar U+0024
let blackHeart = &quot;\u{2665}&quot;      // ♥,  Unicode scalar U+2665
let sparklingHeart = &quot;\u{1F496}&quot; // 💖, Unicode scalar U+1F496

结果:
$ ♥ 💖
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;空字符串&quot;&gt;空字符串&lt;/h2&gt;
&lt;p&gt;我们来看一下如果定义一个空字符串:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var emptyString = &quot;&quot;
或者
var emptyString = String()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;判断字符串是否为空:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;isEmpty 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emptyString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;emptyStirng is empty&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符串可变性&quot;&gt;字符串可变性&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;

结果:
variableStrin:Horse and carriage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let constantString = &quot;Highlander&quot;
constantString += &quot; and another Highlander&quot;
发生错误。
Left side of mutating operator isn't mutable: 'constantString' is a 'let' constant
变异操作符的左侧是不可改变的:“常量字符串”是一个“let”常量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;简单来说就是variableString 是变量,可以通过+操作符来追加字符串, constantString 为常量,不可修改。&lt;/p&gt;

&lt;p&gt;这个我不得不吐槽一下,官网的这个解释,不就是常量不可修改嘛,说什么可变性。&lt;/p&gt;

&lt;h2 id=&quot;字符串是值类型&quot;&gt;字符串是值类型&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;If you create a new String value, that String value is copied when it’s passed to a function or method, or when it’s assigned to a constant or variable. In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version.
如果您创建一个新的字符串值，那么当它传递给一个函数或方法时，或者当它被分配给一个常量或变量时,该字符串值将被复制。
在不同情况下，都会创建一个现有字符串值的新副本，并分配新副本，而不是原始版本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift’s copy-by-default String behavior ensures that when a function or method passes you a String value, it’s clear that you own that exact String value, regardless of where it came from. You can be confident that the string you are passed won’t be modified unless you modify it yourself.
Swift的 copy-by-default 行为可以确保当函数或方法传递给你一个字符串值时，不管它是从哪里来的，你都能清楚地知道你的值是什么。您可以确信，您所传递的字符串不会被修改，除非您自己修改它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.
在后台,Swift的编译器优化了字符串的使用，所以只有在绝对必要的情况下才会进行实际的复制。这意味着在使用字符串作为值类型时，您总是获得很好的性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个就有别于OC了，OC中有明确的分为NSString(不可变)和NSMutableString(可变),swift中只有这么一种了，通过对此的优化更加确保了数据的安全。&lt;/p&gt;

&lt;h1 id=&quot;字符&quot;&gt;字符&lt;/h1&gt;
&lt;p&gt;定义一个字符(Character)类型的常量charA&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let charA:Character = &quot;A&quot;
print(&quot;charA:\(charA)&quot;)
结果:
charA:A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;您可以通过使用for循环遍历字符串来访问字符串的单个字符值:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let character = &quot;&quot;
let str = &quot;窗外的麻雀&quot;
for character in str {
    print(character)
}
结果:
窗
外
的
麻
雀
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建一个字符值数组:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]
print(catCharacters)
结果:
[&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;String(字符数组) &lt;/code&gt;来将字符数组转换成字符串&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]
let catString = String(catCharacters)
print(catString)
结果:
Cat!🐱
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字符串的连接:
我们可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 操作符连接字符串&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2
print(&quot;welcome \(welcome)&quot;)
结果:
welcome hello there
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;操作符之外,还有append方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2

let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
print(&quot;welcome \(welcome)&quot;)
结果:
welcome hello there!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;append是将字符串追加到原本字符串的末尾&lt;/p&gt;

&lt;p&gt;以上的添加方法是通过连接两个字符串的值形成一个新的值
而在有的时候我们其实只需要临时的展示而已，不需要去改变原有的值,那么这个时候其实只需要这样做就可以了:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let badStart = &quot;&quot;&quot;
one
two
&quot;&quot;&quot;
let end = &quot;&quot;&quot;
three
&quot;&quot;&quot;
print(badStart + end)
print(badStart)

结果:
one
twothree

one
two
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到我们在输出print中将其相加,虽然显示了，但其实badStart的结果并没有改变。&lt;/p&gt;

&lt;h2 id=&quot;字符串的插值&quot;&gt;字符串的插值&lt;/h2&gt;
&lt;p&gt;在使用字符串的时候，我们可能需要利用其它的变量来改变我们目前的数据,而这个时候我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;\(value)&lt;/code&gt; 来将我们需要的值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;

结果:
3 times 2.5 is 7.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当然了，这个也不是万能，它是不能将未转义的&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;直接放置于&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;中的:
错误的方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let message = &quot;\(\)&quot;
print(message)

let message = &quot;\(\')&quot;
print(message)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正确的方式是这样的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let message = &quot;\(&quot;\'&quot;)&quot;
print(message)
结果:
'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;计算字符的个数&quot;&gt;计算字符的个数&lt;/h2&gt;
&lt;p&gt;计算字符的个数是我们比较常用的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;
print(&quot;unusualMenagerie has \(unusualMenagerie.count) characters&quot;)
结果:
unusualMenagerie has 40 characters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然了,count并不总是能够计算清楚我们的字符个数:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var word = &quot;cafe&quot;
print(&quot;the number of characters in \(word) is \(word.count)&quot;)
这个计算结果是4
word += &quot;\u{301}&quot;  
print(&quot;the number of characters in \(word) is \(word.count)&quot;)
当我们计算的会发现结果仍然是4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这是为什么呢?
因为swift中的字符串运用了&lt;code class=&quot;highlighter-rouge&quot;&gt;扩展字元簇（Extended Grapheme Clusters)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;扩展字元簇可以由多个Unicode标量组成。
&lt;strong&gt;这意味着不同的字符和相同字符的不同表示可以要求不同的内存数量来存储。
因此，Swift中的字符不会在字符串的表示中占用相同数量的内存。&lt;/strong&gt;
结果，字符串中的字符数无法计算.
如果您使用的是特别长的字符串值，请注意，count属性必须遍历整个字符串中的Unicode标量，以便确定该字符串的字符。&lt;/p&gt;

&lt;p&gt;比如：字母é可以是一个单独的Unicode scalar：U+00E9，也可以是多个纯量的组合：U+0065U+0301 （其中U+0065就是字母e）。在Swift中，这两种情况都认为是一个字符，因此获取字符串长度的时候(用全局函数count())，返回的值是相同的，这意味着字符串的改变并不一定意味着其长度发生变化。&lt;/p&gt;

&lt;p&gt;count属性返回的字符数并不总是与包含相同字符的NSString的长度属性相同。
NSString的length是基于字符串的utf-16表示的16位代码单元的数量，而不是字符串中Unicode扩展的grapheme集群的数量&lt;/p&gt;

&lt;h2 id=&quot;字符串索引&quot;&gt;字符串索引&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let greeting = &quot;Guten Tag!&quot;
//字符串中的开头字母
print(greeting[greeting.startIndex])
//index()表示获取字符串中某个下标的元素,before意味着获取最后一位的之前的下标
//endIndex表示字符串最后一位
print(greeting[greeting.index(before: greeting.endIndex)])
//after表示获取某个下标之后
print(greeting[greeting.index(after: greeting.startIndex)])
//这个方法表示以startIndex下标开始，偏移7位
let index = greeting.index(greeting.startIndex, offsetBy: 7)
print(greeting[index])
结果:
G
!
u
a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用索引属性来访问字符串中各个字符的所有索引:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index in greeting.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
结果:
G u t e n   T a g ! 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的terminator是print方法中参数,默认是添加换行符\n&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let greeting = &quot;Guten Tag!&quot;

for index in greeting.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;\n&quot;)
}
G 
u 
t 
e 
n 
  
T 
a 
g 
! 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;感觉跟print没有区别吧。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let greeting = &quot;Guten Tag!&quot;

for index in greeting.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;1&quot;)
}
结果:
G 1u 1t 1e 1n 1  1T 1a 1g 1! 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个其实就是在每次获取单个字符之后添加一个字符。&lt;/p&gt;

&lt;h1 id=&quot;字符串的插入和删除&quot;&gt;字符串的插入和删除&lt;/h1&gt;

&lt;h2 id=&quot;插入&quot;&gt;插入&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;insert(value,at:index)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at:welcome.endIndex)
print(welcome)
结果:
hello!

var welcome = &quot;hello!&quot;
welcome.insert(contentsOf: &quot; world&quot;, at: welcome.index(before: welcome.endIndex))
print(welcome)
结果:
hello world!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;移除&quot;&gt;移除&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;remove(at:index)
根据下标进行移除&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;removeSubrange
根据提供的范围进行移除
```
var welcome = “hello!”
welcome.remove(at: welcome.index(before: welcome.endIndex))
print(welcome)
结果:
hello&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;var welcome = “hello world”
//空格的位置 - 末尾
let range = welcome.index(welcome.endIndex, offsetBy: -6)..&amp;lt;welcome.endIndex
welcome.removeSubrange(range)
print(welcome)
结果:
hello
```
后续更新,敬请期待…&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/03/swiftStringAndCharacter.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/03/swiftStringAndCharacter.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>数组中关于防止奔溃的解决方案</title>
        <description>&lt;p&gt;&lt;small&gt;
项目中经常遇到数组越界的情况，这是个很烦人的问题，所以，就思考了下如何避免这样的问题。
首先我们获取数组元素的方式分为:&lt;/small&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *array = @[@1,@2];
NSLog(@&quot;arrary: %@&quot;,[array objectAtIndex:2]);
NSLog(@&quot;arrary: %@&quot;,array[2]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;是的，通过objectAtIndex和[] 方式。&lt;/p&gt;

&lt;p&gt;然后我们是不是第一个想法就是写分类然后重写？
嗯，我的确是试了一下，然后发现并没有用，系统这样提示我:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Category is implementing a method which will also be implemented by its primary class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WTF? 警告，说这里重写也没有用？那怎么办？
而且还有一个问题就是，objectAtIndex方法很明确了，那么[] 这是个什么鬼？这也能用方法来表示？是的。
有两种方式可以知道：
第一种直接看错误:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-12-29 19:25:36.510723+0800 OCTest[39152:4167702] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndexedSubscript:]: index 3 beyond bounds [0 .. 1]'
*** First throw call stack:
(
	0   CoreFoundation                      0x00007fff4150700b __exceptionPreprocess + 171
	1   libobjc.A.dylib                     0x00007fff680e5c76 objc_exception_throw + 48
	2   CoreFoundation                      0x00007fff41548514 _CFThrowFormattedException + 202
	3   CoreFoundation                      0x00007fff415b9201 -[__NSArrayI objectAtIndexedSubscript:] + 97
	4   OCTest                              0x0000000100000e55 main + 245
	5   libdyld.dylib                       0x00007fff68cd5115 start + 1
)
libc++abi.dylib: terminating with uncaught exception of type NSException
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们人为越界了一下，发现了错误所在
` [__NSArrayI objectAtIndexedSubscript:]`
是的，这里告诉我们就是它发生了错误.
第二种：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在main.m文件中写下如下代码:
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray *array = @[@1,@2];
        NSLog(@&quot;arrary: %@&quot;,[array objectAtIndex:2]);
        NSLog(@&quot;arrary: %@&quot;,array[3]);
    }
    return 0;
}

然后通过命令行:
clang -rewrite-objc main.m
得到
main.cpp
拉倒最后:
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        NSArray *array = ((NSArray *(*)(Class, SEL, ObjectType  _Nonnull const * _Nonnull, NSUInteger))(void *)objc_msgSend)(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;arrayWithObjects:count:&quot;), (const id *)__NSContainer_literal(2U, ((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(&quot;NSNumber&quot;), sel_registerName(&quot;numberWithInt:&quot;), 1), ((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(&quot;NSNumber&quot;), sel_registerName(&quot;numberWithInt:&quot;), 2)).arr, 2U);
        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_2d_q947d5pn4z3dfyq0j4vqsq840000gn_T_main_9976d7_mi_0,((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)array, sel_registerName(&quot;objectAtIndexedSubscript:&quot;), (NSUInteger)1));
        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_2d_q947d5pn4z3dfyq0j4vqsq840000gn_T_main_9976d7_mi_1,((id (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)array, sel_registerName(&quot;objectAtIndex:&quot;), (NSUInteger)1));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过代码我们也知道了[]调用的方式:
&lt;code class=&quot;highlighter-rouge&quot;&gt;sel_registerName(&quot;objectAtIndexedSubscript:&quot;)&lt;/code&gt;
里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;objectAtIndexedSubscript &lt;/code&gt;方法就是当我们使用[]的时候底层调用的方法。
当然，它也无法重写。&lt;/p&gt;

&lt;p&gt;知道了原因，我们却无法重写，真是一个悲伤的故事。于是我找啊找啊，就找到了一种可以替代方法的方法。不给上，哥就不上了? 那也太怂了是吧。
我找到的就是runtime中的替换方法。
官方解释网址:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://developer.apple.com/documentation/objectivec/1418530-class_getinstancemethod&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Method class_getInstanceMethod(Class cls, SEL name);
Returns a specified instance method for a given class.
为给定的类返回指定的实例方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先通过这个方法获取指定的实例方法.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://developer.apple.com/documentation/objectivec/1418769-method_exchangeimplementations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;void method_exchangeImplementations(Method m1, Method m2);
Exchanges the implementations of two methods.
交换两种方法的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们再自己实现个方法，这方法里面我们做一下规避操作。比如用try catch把异常给捕捉起来，然后打上日志。就不用担心会崩溃，也不知道哪里发生了错误。当然具体的方法要根据业务场景自我实现。&lt;/p&gt;

&lt;p&gt;下面的__NSArrayI 和__NSArrrayM分别代表不可变数组和可变数组的真实类型&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(@&quot;type of array:%@&quot;,[array class]);
NSLog(@&quot;type of mutableArray:%@&quot;,[mArray class]);

结果如下:
2017-12-29 19:46:08.048887+0800 OCTest[39319:4202006] type of array:__NSArrayI
2017-12-29 19:46:08.048905+0800 OCTest[39319:4202006] type of mutableArray:__NSArrayM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;NSArray+BoundsOfRang.h&quot;
#import &amp;lt;objc/runtime.h&amp;gt;

@implementation NSArray (BoundsOfRang)

+ (void)load{
    [super load];
    // 替换不可变数组中的方法 objectAtIndex
    Method oldObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:));
    Method newObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(newObjectAtIndex:));
    method_exchangeImplementations(oldObjectAtIndex, newObjectAtIndex);
    // 替换不可变数组中的方法 []调用的方法
    Method oldMutableObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndexedSubscript:));
    Method newMutableObjectAtIndex =  class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(newObjectAtIndexedSubscript:));
    method_exchangeImplementations(oldMutableObjectAtIndex, newMutableObjectAtIndex);
    
    // 替换可变数组中的方法 objectAtIndex
    Method oldMObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(objectAtIndex:));
    Method newMObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(newMutableObjectAtIndex:));
    method_exchangeImplementations(oldMObjectAtIndex, newMObjectAtIndex);
    // 替换可变数组中的方法  []调用的方法
    Method oldMMutableObjectAtIndex = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(objectAtIndexedSubscript:));
    Method newMMutableObjectAtIndex =  class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(newMutableObjectAtIndexedSubscript:));
    method_exchangeImplementations(oldMMutableObjectAtIndex, newMMutableObjectAtIndex);
}

- (id)newObjectAtIndex:(NSUInteger)index{
    if (index &amp;gt; self.count - 1 || !self.count){
        @try {
            return [self newObjectAtIndex:index];
        } @catch (NSException *exception) {
            NSLog(@&quot;不可数组越界了&quot;);
            return nil;
        } @finally {

        }
    }
    else{
        return [self newObjectAtIndex:index];
    }
}

- (id)newObjectAtIndexedSubscript:(NSUInteger)index{
    if (index &amp;gt; self.count - 1 || !self.count){
        @try {
            return [self newObjectAtIndexedSubscript:index];
        } @catch (NSException *exception) {
            NSLog(@&quot;不可数组越界了&quot;);
            return nil;
        } @finally {
        }
    }
    else{
        return [self newObjectAtIndexedSubscript:index];
    }
}



- (id)newMutableObjectAtIndex:(NSUInteger)index{
    if (index &amp;gt; self.count - 1 || !self.count){
        @try {
            return [self newMutableObjectAtIndex:index];
        } @catch (NSException *exception) {
            NSLog(@&quot;可变数组越界了&quot;);
            return nil;
        } @finally {
            
        }
    }
    else{
        return [self newMutableObjectAtIndex:index];
    }
}

- (id)newMutableObjectAtIndexedSubscript:(NSUInteger)index{
    if (index &amp;gt; self.count - 1 || !self.count){
        @try {
            return [self newMutableObjectAtIndexedSubscript:index];
        } @catch (NSException *exception) {
            NSLog(@&quot;可变数组越界了&quot;);
            return nil;
        } @finally {
        }
    }
    else{
        return [self newMutableObjectAtIndexedSubscript:index];
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;/small&amp;gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/01/03/BoundsOfRang.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2018/01/03/BoundsOfRang.html</guid>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Swift - 开始</title>
        <description>&lt;p&gt;本系列采用的是Apple 官方的 4.0API&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-2e0308776f3d3ac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/250&quot; alt=&quot;swift 4.0.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;毕竟不是百科全书,所以不可能解释的很全面,我只能提供我自己的套路和学习方式供大家参考.&lt;/p&gt;

&lt;p&gt;在编写的过程中会采用官方文档中的一些实例和原文翻译，也会加上一些自己的想法，因为想系统的学习一下，所以周期可能比较长。&lt;/p&gt;

&lt;p&gt;一.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;快速浏览大纲,明白自己接下所需要接触的知识点&lt;/li&gt;
  &lt;li&gt;根据知识点快速学习,比如常量,可以快速记一下,常量是什么,然后再看一下它的定义,
再自己做一遍, 明白它的用法. 这样很快的,这个知识点就可以过了.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过第一遍的学习,基本可以了解到 这个知识点的定义,使用方式,使用过程中的注意事项.&lt;/p&gt;

&lt;p&gt;二.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;知道每个知识的使用方式和定义之后
我们还需要更深层次的去了解它的使用环境,注意事项,如何灵活运用它等等
这个是需要查资料,自己做的过程中去总结经验的.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;通过第二遍的学习,你会更加的深入的去探讨它的功能,扩展性,功能性意义等等.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;三.
这个阶段不是一蹴而就的,是囊括整个行业生涯的. 
以前我觉得三遍学习法只是说
三遍不同程度的学习就能够掌握一定程度的知识,其实不然. 
这个阶段应该是明悟各种设计模式,各种框架的本质,探索不同知识点在不同环境下的不同变化,
而这个变化根本不是说你做个几个项目就能明白的. 
就如属性+方法+协议+类,就能实现代理这种模式,
而这种模式在不同的环境下使用的效率,使用的可行性,都会不同. 
随着渐渐的深入理解,才会更加明白我们目前写的东西的意义.&lt;/p&gt;

&lt;p&gt;就如盖一栋大楼,工人和设计师都是不可或缺的一员,但是设计师的价值和需求却大于工人. 
就是因为工人虽然是不可或缺的,但是他们能做的是根据设计图去拼凑,组装. 却无法做到发明.&lt;/p&gt;

&lt;p&gt;一件事物 从无到有,最为关键得永远都是0到1这个过程,
1-100这个过程只要这个物品满足社会需求和可行性,必然都会被完善的.&lt;/p&gt;

&lt;p&gt;第三阶段 其实已经取决个人的追求,是混口饭吃,还是说探索设计模式,研发算法,设计应用框架之道等等.&lt;/p&gt;

&lt;p&gt;没有优劣,没有对错,凡是自己认定目标,并且坚定不移的去执行的,在我看来,此生无憾矣.&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/swift/2018/01/02/SwiftStart.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/2018/01/02/SwiftStart.html</guid>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>CAKeyframeAnimation 关键帧动画</title>
        <description>&lt;p&gt;贝塞尔曲线的基础我们了解了，接下来，我们开始自己做一些动画效果。
那么配合贝塞尔曲线的一般使用关键帧动画。为啥呢？因为我喜欢啊,哈哈哈哈！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们之前使用过CATransition,CATransition直接继承于CAAnimation。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-f73c98bd6d124c6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;动画关系图.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CAAnimation 简单来说是从一个值到另一个值得变化。（例如我们设置某个视图的颜色为红色,然后在动画中设置结果为绿色,那么就会显示这两种值得变化）&lt;/p&gt;

&lt;p&gt;而我们今天用的动画CAKeyframeAnimation继承于CAPropertyAnimation，CAPropertyAnimation虽然也继承于CAAnimation,但是CAPropertyAnimation在CAAnimation基础上增加了一种路径属性的设置。我们不再仅限于改变两个值的变化，而是路径中不同坐标点的变化。&lt;/p&gt;

&lt;p&gt;接下来我们就可以了解一下: CAKeyframeAnimation
附加官网文档地址:
https://developer.apple.com/documentation/quartzcore/cakeyframeanimation?language=objc&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property(nullable, copy) NSArray *values;
这个属性我们在之前的心心动画中已经运用到多了。简单来说就是:
@[@1,@3,@4,@5] 我们使用CAAnimation可以会设置属性值@1和@3之间的变化，而我们利用values就可以
逐个的从@1依次到@5产生变化。

这个属性是只有path属性为nil的时候才有效果
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们简单的使用代码实现一下:&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;CAKeyframeAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;CAKeyframeAnimation&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;animationWithKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;transform.scale&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;keyAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;keyAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyAnimation&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;forKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;transform.scale&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-62158727514bbd52.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;values Test.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到,我们设置了视图的transform.scale 即缩放属性。然后设置它值得变化是@1,@2,@3,@4,@3,@2,@1，也就是从小到大，然后从大到小。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(nullable) CGPathRef path;
这个属性就是我们设置了path之后，视图会跟着路径去移动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们做个简单的路径动画:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-2e0991a0417f3107.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/240&quot; alt=&quot;path.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先绘制一个Z字型路径:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_bezier = [UIBezierPath bezierPath];
[_bezier moveToPoint:(CGPoint){0,100}];
[_bezier addLineToPoint:(CGPoint){kSCREENWIDTH,100}];
[_bezier addLineToPoint:(CGPoint){0,200}];
[_bezier addLineToPoint:(CGPoint){kSCREENWIDTH,200}];
[_bezier closePath];
[_bezier setLineWidth:0.2];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后将绘制好的路径设置到动画当中&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//路径动画
CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
keyAnimation.duration = 6.0f;
keyAnimation.path = _bezier.CGPath;
[self.label.layer addAnimation:keyAnimation forKey:@&quot;position&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(nullable, copy) NSArray&amp;lt;NSNumber *&amp;gt; *keyTimes;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官网中这样写道:
https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412522-keytimes?language=objc&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each value in the array is a floating point number between 0.0 and 1.0 that defines the time point (specified as a fraction of the animation’s total duration) at which to apply the corresponding keyframe value. 
数组中的每个值都是介于0.0和1.0之间的浮点数，它定义了时间点(指定为动画总长度的一小部分)，用于应用对应的关键帧值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each successive value in the array must be greater than, or equal to, the previous value.
数组中的每一个连续值都必须大于或等于前面的值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该属性是一个数组，每个值分别对应每个子路径(AB,BC,CD,DE)的时间。
如果你没有显式地对keyTimes进行设置，则系统会默认每条子路径的时间为：ti=duration/(帧数)，即每条子路径的duration相等&lt;/p&gt;

&lt;p&gt;我们在上述的动画中加入该属性之后，观看一下效果:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-7b589157df01194a.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;keyTimes.gif&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//路径动画
CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
keyAnimation.path = _bezier.CGPath;
keyAnimation.keyTimes = @[@(0.0f),@(0.1f),@(0.2f),@(0.3f),@(0.4f)];
keyAnimation.duration = 6.0f;
[self.label.layer addAnimation:keyAnimation forKey:@&quot;position&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到我们在设置了对应的速度之后,它们的时候速度明显变快了.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(copy) NSString *calculationMode;
计算模式在关键帧动画中也非常重要,效果比较类似于下面说到的timingFunctions。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它一般可以配合keyTimes属性进行设置。在官网介绍keyTimes的时候有这样一段话:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The appropriate values to include in the array are dependent on the calculationMode property.
在数组中包含的适当值依赖于计算模式属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the calculationMode is set to kCAAnimationLinear or kCAAnimationCubic, 
the first value in the array must be 0.0 and the last value must be 1.0. 
All intermediate values represent time points between the start and end times.
如果将计算模式设置为kCAAnimationLinear或kCAAnimationCubic，那么数组中的第一个值必须是0.0，
最后一个值必须是1.0。所有中间值都表示开始和结束时间之间的时间点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the calculationMode is set to kCAAnimationDiscrete, 
the first value in the array must be 0.0 and the last value must be 1.0. 
The array should have one more entry than appears in the values array. For example, 
if there are two values, there should be three key times.
如果将计算模式设置为kCAAnimationDiscrete，那么数组中的第一个值必须是0.0，最后一个值必须是1.0。
该数组应该有一个比在值数组中显示的还要多的条目。例如，如果有两个值，则应该有三个关键时刻。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the calculationMode is set to kCAAnimationPaced or kCAAnimationCubicPaced, the values in this property are ignored.
如果将计算模式设置为kCAAnimationPaced或kCAAnimationCubicPaced，那么该属性的值就会被忽略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the values in this array are invalid or inappropriate for the current calculation mode, they are ignored.
如果该数组中的值无效或不适合当前计算模式，则会忽略它们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它的值如下所示:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;默认值,表示当关键帧为坐标点的时候,关键帧之间线性运动; 
CA_EXTERN NSString * const kCAAnimationLinear
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

所有关键帧直接逐个运动; 
CA_EXTERN NSString * const kCAAnimationDiscrete
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效; 
CA_EXTERN NSString * const kCAAnimationPaced
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

对关键帧为坐标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,
这里的主要目的是使得运行的轨迹变得圆滑; 
CA_EXTERN NSString * const kCAAnimationCubic
    CA_AVAILABLE_STARTING (10.7, 4.0, 9.0, 2.0);

在kCAAnimationCubic的基础上使得动画运行变得均匀,
就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的.
CA_EXTERN NSString * const kCAAnimationCubicPaced
    CA_AVAILABLE_STARTING (10.7, 4.0, 9.0, 2.0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(nullable, copy) NSArray&amp;lt;CAMediaTimingFunction *&amp;gt; *timingFunctions;
设置它可以影响动画的阶段速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//线性速度,各阶段保持匀速
CA_EXTERN NSString * const kCAMediaTimingFunctionLinear 
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

//淡入 也就是开头会慢一点
CA_EXTERN NSString * const kCAMediaTimingFunctionEaseIn
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

//淡出 结束的时候会慢
CA_EXTERN NSString * const kCAMediaTimingFunctionEaseOut
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

//淡入淡出 开头和结束的时候会慢
CA_EXTERN NSString * const kCAMediaTimingFunctionEaseInEaseOut
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

//默认
CA_EXTERN NSString * const kCAMediaTimingFunctionDefault
    CA_AVAILABLE_STARTING (10.6, 3.0, 9.0, 2.0);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面的三个值都是配合 calculationMode 的 kCAAnimationCubic值进行使用的。用来调整自定义的曲线
我们可以通过官网的解释来了解一下，有空的话我也会做一些demo来直观了解一下。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;@property(nullable, copy) NSArray&amp;lt;NSNumber *&amp;gt; *tensionValues;
一组NSNumber对象定义了曲线的紧密性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This property is used only for the cubic calculation modes. Positive values indicate a tighter curve while negative values indicate a rounder curve. The first value defines the behavior of the tangent to the first control point, the second value controls the second point’s tangents, and so on. If you do not specify a value for a given control point, the value 0 is used.
该属性仅用于立方计算模式。正值表示一条更紧的曲线，而负值则表示一条圆曲线。第一个值定义了第一个控制点的切线的行为，第二个值控制了第二个点的切线，以此类推。如果不指定给定控制点的值，则使用值0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(nullable, copy) NSArray&amp;lt;NSNumber *&amp;gt; *continuityValues;
一组NSNumber对象，它定义了时间曲线的锐度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This property is used only for the cubic calculation modes. Positive values result in sharper corners while negative values create inverted corners. The first value defines the behavior of the tangent to the first control point, the second value controls the second point’s tangents, and so on. If you do not specify a value for a given control point, the value 0 is used.
该属性仅用于cubic calculation modes。正值会导致更尖锐的角落，而负值则会产生倒角。第一个值定义了第一个控制点的切线的行为，第二个值控制了第二个点的切线，以此类推。如果不指定给定控制点的值，则使用值0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;@property(nullable, copy) NSArray&amp;lt;NSNumber *&amp;gt; *biasValues;
一组NSNumber对象，它定义了相对于控制点的曲线的位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This property is used only for the cubic calculation modes. Positive values move the curve before the control point while negative values move it after the control point. The first value defines the behavior of the tangent to the first control point, the second value controls the second point’s tangents, and so on. If you do not specify a value for a given control point, the value 0 is used.
该属性仅用于cubic calculation modes。正值在控制点前移动曲线，而负值则在控制点之后移动。第一个值定义了第一个控制点的切线的行为，第二个值控制了第二个点的切线，以此类推。如果不指定给定控制点的值，则使用值0。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property(nullable, copy) NSString *rotationMode;
旋转样式

根据路径自动旋转
CA_EXTERN NSString * const kCAAnimationRotateAuto
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);

根据路径自动翻转
CA_EXTERN NSString * const kCAAnimationRotateAutoReverse
    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;好吧，图片总是上传失败，简单来说就是，图像根据路径移动的时候是会调整自身的方向的，不那么刻板的一直是摆在正中间那样的效果。&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%8A%A8%E7%94%BB/2017/12/30/Animation-keyFrame.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%8A%A8%E7%94%BB/2017/12/30/Animation-keyFrame.html</guid>
        
        
        <category>动画</category>
        
      </item>
    
      <item>
        <title>贝塞尔曲线绘制2</title>
        <description>&lt;p&gt;在贝塞尔曲线(1)中，我们介绍了贝塞尔曲线的绘制,但是那是固定的,运用场景很少,运用更多的是一些动画效果。
而前端主要的功能就是负责貌美如花,所以掌握一定的动画技巧还是有必要的。
所以呢，我就开始从简单的慢慢研究吧。&lt;/p&gt;

&lt;p&gt;##下拉动画
首先是如下的效果:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-347576c2e5c3a9e2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/240&quot; alt=&quot;下拉动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先需要分析几个问题:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如何绘制二阶曲线&lt;/li&gt;
  &lt;li&gt;如何让曲线跟随着下拉进行变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;问题的解决有很多种,我写下的只是我的解决思路:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 创建一个视图,重写它的drawRect:方法

UIBezierPath *bezier = [UIBezierPath bezierPath];
UIColor *color = hexStrColor(@&quot;#FF8C69&quot;);
[color set];
bezier.lineWidth = 1.0;
[bezier moveToPoint:(CGPoint){0,0}];
[bezier addQuadCurveToPoint:(CGPoint){self.width,0} controlPoint:(CGPoint){self.width/2,self.offsetY}];
[bezier fill];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过上面的方法,我们绘制了二阶曲线,那么就是解决第二个问题了。&lt;/p&gt;

&lt;p&gt;想让我们的表格下拉的时候，视图也跟着变化,那么肯定需要知道我们表格下拉的具体数值,所以需要实现UIScrollViewDelegate的scrollViewDidScroll方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过该方法我们实时的知道表格的Y轴偏移量,所以我们还需要在之前的视图中添加一个变量:
&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (nonatomic,readwrite,unsafe_unretained)CGFloat offsetY;&lt;/code&gt;
通过该变量来实时的控制二阶曲线的controlPoint参数的Y值。&lt;/p&gt;

&lt;p&gt;接下来,我们在scrollViewDidScroll方法中写下如下代码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.headerView.offsetY = -scrollView.contentOffset.y;
[self.headerView setNeedsDisplay];
[self.headerView setFrame:(CGRect){0,statusBarHeight,kSCREENWIDTH,- scrollView.contentOffset.y}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为我们需要在滑动的时候实时的改变曲线的拐点,然后生成对应的曲线。也就是我们需要实时的重新绘制视图,也就是调用drawRect: 方法.所以我们需要调用setNeedsDisplay方法。通过在外部调用setNeedsDisplay可以是视图重新调用drawRect方法&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;setNeedsLayout会默认调用layoutSubViews, setNeedsDisplay会调用drawRect:方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;##加载动画
接下来我们再做个加载动画，具体的效果如下:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-f72fff75363d19ee.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加载动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是个根据路径变化的动画，也是我在很多软件上经常看到的一种加载动画。所以就自己试试能不能做不出来。
先创建三个球,哈哈，先把我们要玩的球画出来:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGFloat radius = 20;
CGFloat marginLeft = 10;
//第一颗球
CAShapeLayer *fLayer = [CAShapeLayer new];
fLayer.backgroundColor =  getColor(102, 170, 238, 1).CGColor;
[fLayer setFrame:(CGRect){self.width/2-(radius*2+marginLeft*2)/2,self.height/2,radius,radius}];
fLayer.cornerRadius = radius/2;
//第二颗球
CAShapeLayer *sLayer = [CAShapeLayer new];
sLayer.backgroundColor = getColor(102, 170, 238, 0.5).CGColor;
[sLayer setFrame:(CGRect){marginLeft(fLayer)+marginLeft,self.height/2,radius,radius}];
sLayer.cornerRadius = radius/2;
//第三颗球
CAShapeLayer *tLayer = [CAShapeLayer new];
tLayer.backgroundColor = getColor(102, 170, 238, 0.2).CGColor;
[tLayer setFrame:(CGRect){marginLeft(sLayer)+marginLeft,self.height/2,radius,radius}];
tLayer.cornerRadius = radius/2;
    
    
self.layer_list = [NSArray arrayWithObjects:fLayer,sLayer,tLayer,nil];
[self.layer addSublayer:fLayer];
[self.layer addSublayer:sLayer];
[self.layer addSublayer:tLayer];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;球画好了我们就要开始研究它的运动轨迹了。通过一些观察我们分析得出了下面的运动轨迹:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-abd93f18d21599cf.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第一课球的运动动画.gif&quot; /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-8cd887b449a4c6bd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第二颗球运动动画.gif&quot; /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-5ac742af64652897.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第三颗球运动动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过观察，第一颗球的运动轨迹其实就是一个上半圆加上一个下半圆的路径动画。那么只需要画两个半圆就搞定的事咯？我们来试一下&lt;/p&gt;

&lt;p&gt;绘制圆的参考图:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-14d1c6d4de788342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;弧线参考图.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一个半圆是以两个圆的中心点为圆心绘制的半圆,
&lt;code class=&quot;highlighter-rouge&quot;&gt;第一个半圆是 π -&amp;gt; 0° 顺时针运动,然后π -&amp;gt; 0°逆时针运动&lt;/code&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-0f3102e3e05981ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第一颗球的运动轨迹.png&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAShapeLayer *fLayer = self.layer_list[0];
CAShapeLayer *testLayer = [CAShapeLayer new];
testLayer.fillColor = [UIColor clearColor].CGColor;
testLayer.borderWidth = 1.0f;
testLayer.strokeColor = hexStrColor(@&quot;#AA8C69&quot;).CGColor;

UIBezierPath *semicirclePath = [UIBezierPath bezierPath];
//上半圆
[semicirclePath addArcWithCenter:(CGPoint){fLayer.frame.origin.x+25,fLayer.frame.origin.y+10}
                           radius:15
                       startAngle:M_PI
                         endAngle:0
                        clockwise:YES];
//下半圆
[semicirclePath addArcWithCenter:(CGPoint){sLayer.frame.origin.x+25,sLayer.frame.origin.y+10}
                           radius:15
                       startAngle:M_PI
                         endAngle:0
                        clockwise:NO];
testLayer.path = semicirclePathA.CGPath;
[self.layer addSublayer:testLayer];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一颗球的轨迹我们清楚之后我们来设置第二颗球的轨迹:
&lt;code class=&quot;highlighter-rouge&quot;&gt;0° -&amp;gt; π 顺时针运动&lt;/code&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-d2920032746f5893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第二颗球的运动轨迹.png&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CAShapeLayer *fLayer = self.layer_list[0];
    CAShapeLayer *sLayer = self.layer_list[1];
    //第二段动画
    CAShapeLayer *testLeftLayer = [CAShapeLayer new];
    testLeftLayer.fillColor = [UIColor clearColor].CGColor;
    testLeftLayer.borderWidth = 1.f;
    testLeftLayer.strokeColor = [UIColor redColor].CGColor;
    UIBezierPath *leftPath = [UIBezierPath bezierPath];
    [leftPath addArcWithCenter:(CGPoint){fLayer.frame.origin.x+25,fLayer.frame.origin.y+10} 
                        radius:15 startAngle:0 endAngle:M_PI clockwise:YES];
    testLeftLayer.path = leftPath.CGPath;
    [self.layer addSublayer:testLeftLayer];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再来看看第三颗球:
&lt;code class=&quot;highlighter-rouge&quot;&gt;0° -&amp;gt; π 逆时针运动&lt;/code&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-a9dcde2912e87468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第三颗球的运动轨迹.png&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CAShapeLayer *sLayer = self.layer_list[1];
    CAShapeLayer *tLayer = self.layer_list[2];
    //第三段动画
    CAShapeLayer *testRightLayer = [CAShapeLayer new];
    testRightLayer.fillColor = [UIColor clearColor].CGColor;
    testRightLayer.borderWidth = duration;
    testRightLayer.strokeColor = [UIColor blueColor].CGColor;
    
    UIBezierPath *rightPath = [UIBezierPath bezierPath];
    [rightPath addArcWithCenter:(CGPoint){sLayer.frame.origin.x+25,tLayer.frame.origin.y+10} 
                         radius:15 startAngle:0 endAngle:M_PI clockwise:NO];
    testRightLayer.path = rightPath.CGPath;
    [self.layer addSublayer:testRightLayer];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的静态效果图如下:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-74f9042f3aca98ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;静态效果图.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设定好轨迹之后我们就来设置它们的动画效果,动画效果就要用到我们上一篇中提到的关键帧动画了.
由于三个动画具有相同的属性设置，所以我们最好是封装一下,提取出它们会有变化的数值。
例如，动画的依赖视图会变，它们的运动path会变,所以提取出这两个参数。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)keyFrameAnimationWithLayer:(CALayer *)layer path:(UIBezierPath *)path;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
    keyAnimation.path = path.CGPath;
    keyAnimation.fillMode = kCAFillModeForwards;
    keyAnimation.calculationMode = kCAAnimationPaced;
    keyAnimation.removedOnCompletion = NO;
    keyAnimation.duration = duration;
    keyAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    keyAnimation.rotationMode = kCAAnimationRotateAuto;
    keyAnimation.repeatCount = MAXFLOAT;
    keyAnimation.calculationMode = kCAAnimationCubic;
    [layer addAnimation:keyAnimation forKey:@&quot;keyFrameAnimation&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;具体的参数信息已经在上一篇中提过了，这里就不说了。
然后我们开始调用:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//调用第一颗球
[self keyFrameAnimationWithLayer:fLayer path:semicirclePath];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-b70717a25600a727.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第一颗球卡顿的动画.gif&quot; /&gt;
我们运行之后会发现在两个圆的交界处，卡顿了一下下（关于这个问题，我尝试调整了动画的timingFunction属性还有calculationMode都无法很好的解决这个问题,我猜想是由于两个路径是分开绘制的原因，具体的原因还在研究当中。）
不过我还是找到了解决办法:
设置两个路径，然后将路径进行合并成一个路径:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    UIBezierPath *semicirclePathA = [UIBezierPath bezierPath];
    [semicirclePathA addArcWithCenter:(CGPoint){fLayer.frame.origin.x+25,fLayer.frame.origin.y+10} radius:15 startAngle:M_PI endAngle:0 clockwise:YES];
    UIBezierPath *semicirclePathB = [UIBezierPath bezierPath];
    [semicirclePathB addArcWithCenter:(CGPoint){sLayer.frame.origin.x+25,sLayer.frame.origin.y+10} radius:15 startAngle:M_PI endAngle:0 clockwise:NO];
    [semicirclePathA appendPath:semicirclePathB];
    testLayer.path = semicirclePathA.CGPath;
    [self.layer addSublayer:testLayer];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行之后,可以看到效果，如巧克力般丝滑的感觉:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-abd93f18d21599cf.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第一课球的运动动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;画好第一个球之后,我们再来画其他的两个球，基本就相同了,只要调用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)keyFrameAnimationWithLayer:(CALayer *)layer path:(UIBezierPath *)path;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;方法就可以了。&lt;/p&gt;

&lt;p&gt;效果如下:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-86df865f35635ee7.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三颗球运动动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是实现的效果并不如意，它们的颜色变化并不是渐变的，看起来并不好，所以我们还需要添加颜色变换的动画
观察原来的效果总结如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;第一颗球从开始到转到最后的时候，颜色从深色变为了浅色。所以我们可以设定它的变化值为 1 -&amp;gt; 0.2.&lt;/li&gt;
  &lt;li&gt;第二颗球原本是浅色然后旋转到第一的位置时是深色。所以我们可以设定它的变化值为 0.5 -&amp;gt; 1.&lt;/li&gt;
  &lt;li&gt;第三颗球原本是最浅的然后旋转到第二的位置时,颜色变深了一点。所以我们设定它的变化值 0.2 -&amp;gt; 0.5.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动画因为只是两个值得变化 , FromValue -&amp;gt; toValue , 我们采用CABasicAnimation就可以轻松实现效果.
我们同样来封装该动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)colorGradientAnimationWithLayer:(CALayer *)layer fromValue:(id)fromValue toValue:(id)toValue{
    CABasicAnimation *alphaAnimation = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];
    alphaAnimation.fromValue = fromValue;
    alphaAnimation.toValue = toValue;
    alphaAnimation.duration = duration;
    alphaAnimation.repeatCount = MAXFLOAT;
    [layer addAnimation:alphaAnimation forKey:@&quot;anmiationAlpha&quot;];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一颗球的变化
[self colorGradientAnimationWithLayer:fLayer
                                    fromValue:(__bridge id _Nullable)(getColor(102, 170, 238, 1)).CGColor
                                      toValue:(__bridge id _Nullable)(getColor(102, 170, 238, 0.2)).CGColor];
//第二颗球的变化
[self colorGradientAnimationWithLayer:sLayer
                                    fromValue:(__bridge id _Nullable)(getColor(102, 170, 238, 0.5)).CGColor
                                      toValue:(__bridge id _Nullable)(getColor(102, 170, 238, 0.1)).CGColor];
//第三颗球的变化
[self colorGradientAnimationWithLayer:tLayer
                                fromValue:(__bridge id _Nullable)(getColor(102, 170, 238, 0.2)).CGColor
                                  toValue:(__bridge id _Nullable)(getColor(102, 170, 238, 0.5)).CGColor];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;####在制作过程中出现的情况:
1.动画闪烁
keyAnimation.fillMode = kCAFillModeForwards; 可以添加该属性,该属性表示保留动画结束时的效果。
但添加之后发现还是不行,最后发现其实动画结束的坐标点有问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;__bridge 主要是因为我们在编写程序的时候还会用到 CoreFoundation(CF) 框架的对象,CF和 OC 对象之间的类型转换就需要用到__bridge&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后就是我们需要的效果了。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1120896-f72fff75363d19ee.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加载动画.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DEMO:
https://github.com/yanggenwei/GWAnimation/tree/master&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%8A%A8%E7%94%BB/2017/12/29/AnimationBessel-curve2.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%8A%A8%E7%94%BB/2017/12/29/AnimationBessel-curve2.html</guid>
        
        
        <category>动画</category>
        
      </item>
    
  </channel>
</rss>
